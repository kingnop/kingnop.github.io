<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kingnop&#39;s Blog</title>
  <icon>http://www.gravatar.com/avatar/a4a3bb98e8739f3837fef4c8e980aef9</icon>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.kingnop.club/"/>
  <updated>2018-12-24T08:43:49.438Z</updated>
  <id>https://www.kingnop.club/</id>
  
  <author>
    <name>Kingnop</name>
    <email>kingnop@hotmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>并行程序设计实验报告</title>
    <link href="https://www.kingnop.club/2018/12/24/%E5%B9%B6%E8%A1%8C%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
    <id>https://www.kingnop.club/2018/12/24/并行程序设计实验报告/</id>
    <published>2018-12-24T08:30:00.000Z</published>
    <updated>2018-12-24T08:43:49.438Z</updated>
    
    <content type="html"><![CDATA[<p>本文是研一课程《并行程序设计》的实验报告</p><a id="more"></a><h1 id="u5E76_u884C_u7A0B_u5E8F_u8BBE_u8BA1_u5B9E_u9A8C_u62A5_u544A"><a href="#u5E76_u884C_u7A0B_u5E8F_u8BBE_u8BA1_u5B9E_u9A8C_u62A5_u544A" class="headerlink" title="并行程序设计实验报告"></a>并行程序设计实验报告</h1><hr><h2 id="1-__u516C_u5171_u90E8_u5206"><a href="#1-__u516C_u5171_u90E8_u5206" class="headerlink" title="1. 公共部分"></a>1. 公共部分</h2><h3 id="u7528MPI_Send_u548CMPI_Recv_u5B9E_u73B0MPI_Allgather_u7684_u529F_u80FD_uFF0C_u5E76_u6D4B_u8BD5_u6027_u80FD"><a href="#u7528MPI_Send_u548CMPI_Recv_u5B9E_u73B0MPI_Allgather_u7684_u529F_u80FD_uFF0C_u5E76_u6D4B_u8BD5_u6027_u80FD" class="headerlink" title="用MPI_Send和MPI_Recv实现MPI_Allgather的功能，并测试性能"></a>用MPI_Send和MPI_Recv实现MPI_Allgather的功能，并测试性能</h3><p>MPI_Allgaeher是一个多对多通信的函数，其格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MPI_Allgather</span><span class="params">(<span class="keyword">void</span> *SendAddress, <span class="keyword">int</span> SendCount, MPI_Datatype SendDatatype, </span><br><span class="line">                  <span class="keyword">void</span> *RecvAddress, <span class="keyword">int</span> RecvCount, MPI_Datatype RecvDatatype, MPI_Comm Comm)</span></span>;</span><br></pre></td></tr></table></figure><p>其操作相当于每个进程都作为root进程执行了一次Gather调用，即每一个进程都收集来自所有进程（包括自己）的数据。</p><p>而MPI_Send和MPI_Recv是MPI的最基本函数，其调用格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MPI_Send</span><span class="params">(<span class="keyword">void</span> *buf, <span class="keyword">int</span> count, MPI_Datatype datatype, <span class="keyword">int</span> dest, <span class="keyword">int</span> tag, MPI_Comm comm)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MPI_Recv</span><span class="params">(<span class="keyword">void</span> *buf, <span class="keyword">int</span> count, MPI_Datatype datatype, </span><br><span class="line">             <span class="keyword">int</span> source, <span class="keyword">int</span> tag, MPI_Comm comm, MPIStatus status)</span></span>;</span><br></pre></td></tr></table></figure><p>从MPI_Allgather的原理中不难看出，假设共有n个进程，只要让通信域内的每个进程都执行(n-1)次MPI_Send和MPI_Recv函数，然后自己把自己的数据由发送缓存存放到接受缓存中即可。实现代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">My_MPI_Allgather</span><span class="params">(<span class="keyword">int</span>* send_data, <span class="keyword">int</span> send_count, MPI_Datatype send_datatype, </span><br><span class="line">                      <span class="keyword">int</span>* recv_data, <span class="keyword">int</span> recv_count, MPI_Datatype recv_datatype, MPI_Comm communicator)</span></span><br><span class="line"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">int</span> rank, nproc;</span><br><span class="line">MPI_Status status;</span><br><span class="line">MPI_Comm_size(MPI_COMM_WORLD, &amp;nproc);</span><br><span class="line">MPI_Comm_rank(MPI_COMM_WORLD, &amp;rank);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;nproc; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i != rank) <span class="comment">//不给自己发送</span></span><br><span class="line">MPI_Send(send_data, send_count, send_datatype, i, rank, communicator);</span><br><span class="line">&#125;</span><br><span class="line">MPI_Barrier(MPI_COMM_WORLD);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;nproc; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i != rank) <span class="comment">//不接受自己的数据</span></span><br><span class="line">MPI_Recv(&amp;recv_data[i], recv_count, recv_datatype, i, i, communicator, &amp;status);</span><br><span class="line"><span class="keyword">else</span> <span class="comment">//直接把自己的数据从发送缓存保存到接受缓存中去</span></span><br><span class="line">recv_data[i] = *send_data;</span><br><span class="line">&#125;</span><br><span class="line">MPI_Barrier(MPI_COMM_WORLD);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>My_MPI_Allgather函数仿照MPI_Allgather函数实现，传入参数与原生函数相同。函数内实现了上述说的功能，所有进程将数据发送给其他进程，调用MPI_Barrier函数等待通信域内所有进程发送结束，然后所有进程接收其他进程发来的消息。</p><p>用脚本分别运行原本的MPI_Allgather和自己实现的My_MPI_Allgather100次，时间记录如下图（4个处理器）。</p><p><img src="C:\Users\kingn\AppData\Roaming\Typora\typora-user-images\1545048073970.png" alt="1545048073970"><br>运行时间平均值分别为0.000219和0.000223。方差分别为 $ 2.21166\times10^{-8} $和$1.35786\times10^{-8}$，可以看出MPI原生实现具有更好的效率。推测在需要通信的数据量更大的情况下，MPI原生实现的优势将更大。</p><p>抽象的并行算法描述如下：</p><blockquote><p><strong>Begin</strong></p><p>对所有处理器 $rank(rank=0, \cdots, p-1)$同时执行如下的算法：</p><ul><li><p><strong>if(i != rank) then</strong></p><ul><li>执行MPI_Send函数将待发送数据发送到第i个处理器中</li><li><strong>end if</strong></li></ul></li><li><p>等待所有处理器发送完毕</p></li><li><p><strong>if(i != rank) then</strong></p><ul><li><p>执行MPI_Recv函数收取第i个处理器发过来的数据</p></li><li><p><strong>else</strong></p></li><li><p>将自身的数据拷贝到接收缓存中</p></li><li><p><strong>end if</strong></p></li></ul></li></ul><p><strong>End</strong></p></blockquote><hr><h3 id="FOX_u77E9_u9635_u76F8_u4E58_u7684MPI_u5E76_u884C_u7B97_u6CD5_u5B9E_u73B0"><a href="#FOX_u77E9_u9635_u76F8_u4E58_u7684MPI_u5E76_u884C_u7B97_u6CD5_u5B9E_u73B0" class="headerlink" title="FOX矩阵相乘的MPI并行算法实现"></a><strong>FOX矩阵相乘的MPI并行算法实现</strong></h3><p>Fox算法（Fox Algorithm）是一个计算矩阵乘法的并行算法。</p><p>抽象的并行算法描述如下：</p><p><strong>输入：</strong>$A<em>{n\times n}$，$B</em>{n\times n}$注意矩阵$A$和$B$都为方阵</p><p><strong>输出：</strong>$C_{n\times n}$</p><p><strong>Begin</strong></p><p>​    对所有处理器$my_rank(my_rank=0, \cdots, p-1)$同时执行如下的算法</p><ul><li><p>将输入的矩阵$A$和$B$分成$p$个方块，$A<em>{i.j}$和$B</em>{i.j}(0\leq \sqrt{p}-1)$，其中每块大小为$(n/\sqrt{p})\times (n/\sqrt{p})$</p></li><li><p>将$p$个方块分配给$\sqrt{p}\times \sqrt{p}$个处理器</p></li><li><p>处理器按照行和列划分为两个通信子域，每个处理器$P<em>{i,j}$存放有矩阵块$A</em>{i,j}$和$B<em>{i,j}$，并负责计算矩阵块$C</em>{i,j}$</p></li><li><p>For i=0 to $\sqrt{p}$ :</p><ul><li>把$A_{i,i}$向行子域进行一到多播送</li><li>各处理器计算$temp=temp + A<em>{i,i}\times B</em>{i,j}$</li><li>$B<em>{i,j}-&gt;B</em>{i+1,j}$</li><li>$A<em>{i,j}-&gt;A</em>{i,j+1}$</li><li>转到第二步重复</li></ul></li></ul><p><strong>End</strong></p><p>下面是实现Fox算法的函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Fox</span><span class="params">(</span><br><span class="line">        <span class="keyword">int</span>              n         <span class="comment">/* in  */</span>, </span><br><span class="line">        GRID_INFO_T*     grid      <span class="comment">/* in  */</span>, </span><br><span class="line">        LOCAL_MATRIX_T*  local_A   <span class="comment">/* in  */</span>,</span><br><span class="line">        LOCAL_MATRIX_T*  local_B   <span class="comment">/* in  */</span>,</span><br><span class="line">        LOCAL_MATRIX_T*  local_C   <span class="comment">/* out */</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    LOCAL_MATRIX_T*  temp_A; <span class="comment">/* Storage for the sub-    */</span></span><br><span class="line">                             <span class="comment">/* matrix of A used during */</span> </span><br><span class="line">                             <span class="comment">/* the current stage       */</span></span><br><span class="line">    <span class="keyword">int</span>              stage;</span><br><span class="line">    <span class="keyword">int</span>              bcast_root;</span><br><span class="line">    <span class="keyword">int</span>              n_bar;  <span class="comment">/* n/sqrt(p)               */</span></span><br><span class="line">    <span class="keyword">int</span>              source;</span><br><span class="line">    <span class="keyword">int</span>              dest;</span><br><span class="line">    MPI_Status       status;</span><br><span class="line"></span><br><span class="line">    n_bar = n/grid-&gt;q;</span><br><span class="line">    Set_to_zero(local_C);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Calculate addresses for circular shift of B */</span>  </span><br><span class="line">    source = (grid-&gt;my_row + <span class="number">1</span>) % grid-&gt;q;</span><br><span class="line">    dest = (grid-&gt;my_row + grid-&gt;q - <span class="number">1</span>) % grid-&gt;q;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set aside storage for the broadcast block of A */</span></span><br><span class="line">    temp_A = Local_matrix_allocate(n_bar);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (stage = <span class="number">0</span>; stage &lt; grid-&gt;q; stage++) &#123;</span><br><span class="line">        bcast_root = (grid-&gt;my_row + stage) % grid-&gt;q;</span><br><span class="line">        <span class="keyword">if</span> (bcast_root == grid-&gt;my_col) &#123;</span><br><span class="line">            MPI_Bcast(local_A, <span class="number">1</span>, <span class="keyword">local_matrix_mpi_t</span>,</span><br><span class="line">                bcast_root, grid-&gt;row_comm);</span><br><span class="line">            Local_matrix_multiply(local_A, local_B, </span><br><span class="line">                local_C);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            MPI_Bcast(temp_A, <span class="number">1</span>, <span class="keyword">local_matrix_mpi_t</span>,</span><br><span class="line">                bcast_root, grid-&gt;row_comm);</span><br><span class="line">            Local_matrix_multiply(temp_A, local_B, </span><br><span class="line">                local_C);</span><br><span class="line">        &#125;</span><br><span class="line">        MPI_Sendrecv_replace(local_B, <span class="number">1</span>, <span class="keyword">local_matrix_mpi_t</span>,</span><br><span class="line">            dest, <span class="number">0</span>, source, <span class="number">0</span>, grid-&gt;col_comm, &amp;status);</span><br><span class="line">    &#125; <span class="comment">/* for */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="2-__u4E2A_u4EBA_u5B9E_u9A8C"><a href="#2-__u4E2A_u4EBA_u5B9E_u9A8C" class="headerlink" title="2. 个人实验"></a>2. 个人实验</h2><p>个人实验部分我选择的是对RSA加密算法的并行化处理。</p><blockquote><p>RSA加密算法是一种非对称的加密算法。对极大整数做因数分解的难度决定了RSA算法的可靠性。换言之，对一极大整数做因数分解愈困难，RSA算法愈可靠。假如有人找到一种快速因数分解的算法的话，那么用RSA加密的信息的可靠性就肯定会极度下降。但找到这样的算法的可能性是非常小的。今天只有短的RSA钥匙才可能被强力方式解破。到目前为止，世界上还没有任何可靠的攻击RSA算法的方式。只要其钥匙的长度足够长，用RSA加密的信息实际上是不能被解破的。</p></blockquote><h3 id="u516C_u94A5_u548C_u79C1_u94A5_u7684_u4EA7_u751F"><a href="#u516C_u94A5_u548C_u79C1_u94A5_u7684_u4EA7_u751F" class="headerlink" title="公钥和私钥的产生"></a>公钥和私钥的产生</h3><ol><li>随意选择两个大的质数$p$和$q$，$p$不等于$q$。计算$N=p\times q$</li><li>根据欧拉函数，求得$\gamma=\phi(N)=\phi(p)\times\phi(q)=(p-1)\times(q-1)$</li><li>选择一个小于$\gamma$的整数$e$，使得$e$与$\gamma$互质。并求得$e$关于$\gamma$的乘法逆元，记为$d$，满足$ed\equiv 1(\mod \gamma)$（使用扩展欧几里得算法计算）</li><li>将$p$和$q$的记录销毁。此时$(N,e)$是公钥，$(N,d)$是私钥。公钥可以公开出去，而私钥需要保存起来。</li></ol><h3 id="u52A0_u5BC6_u548C_u89E3_u5BC6_u6D88_u606F"><a href="#u52A0_u5BC6_u548C_u89E3_u5BC6_u6D88_u606F" class="headerlink" title="加密和解密消息"></a>加密和解密消息</h3><p>加密消息只需要知道公开的公钥$(N,e)$即可。可以用约定好的规则将消息转化为一个小于$N$的非负数$n$，例如将每个字符转为这个字的Unicode码，然后将这些数字连在一起组成一个数字，如果消息非常长的话可以将消息分为若干段。然后利用下面这个公式就可以将消息加密：<br>$$<br>c\equiv n^{e}(\mod N)<br>$$</p><p>可以利用快速幂算法计算$c$，以防止计算过程中数据溢出。</p><p>对方收到密码消息$c$之后就可以使用私钥$(N,d)$来解密消息：<br>$$<br>n\equiv c^{d}(\mod N)<br>$$</p><h3 id="u5E76_u884C_u65B9_u5F0F_u7684_u9009_u62E9"><a href="#u5E76_u884C_u65B9_u5F0F_u7684_u9009_u62E9" class="headerlink" title="并行方式的选择"></a>并行方式的选择</h3><p>由上述加解密过程我们可以看到，加解密过程实际只涉及到两个快速幂求余的计算，并没有涉及到消息传递的内容，但是因为质数$N$的值非常大，还是需要并行化来加快速度的。因此我选择了OpenMP作为并行化方式。</p><h3 id="u5E76_u884C_u5316_u8BBE_u8BA1"><a href="#u5E76_u884C_u5316_u8BBE_u8BA1" class="headerlink" title="并行化设计"></a>并行化设计</h3><p>实际的并行化设计也比较简单，在快速幂的for循环前面加上OpenMP并行化制导语句就可以了。相关代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">encrypt</span><span class="params">(<span class="keyword">long</span> <span class="keyword">int</span>* in, <span class="keyword">long</span> <span class="keyword">int</span> <span class="built_in">exp</span>, <span class="keyword">long</span> <span class="keyword">int</span> mod, <span class="keyword">long</span> <span class="keyword">int</span>* out, size_t len)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">   <span class="preprocessor">#<span class="keyword">pragma</span> omp parallel for</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">long</span> <span class="keyword">int</span> c = in[i];</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> z=<span class="number">1</span>;z&lt;<span class="built_in">exp</span>;z++)</span><br><span class="line">      &#123;</span><br><span class="line">         c *= in[i];</span><br><span class="line">         c %= mod;</span><br><span class="line">      &#125;</span><br><span class="line">      out[i] = c; </span><br><span class="line">   &#125;</span><br><span class="line">   out[len]=<span class="string">'\0'</span>;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解密的函数内容和加密函数内容完全一致。</p><h3 id="u6570_u636E_u4F9D_u8D56_u5173_u7CFB_u5206_u6790"><a href="#u6570_u636E_u4F9D_u8D56_u5173_u7CFB_u5206_u6790" class="headerlink" title="数据依赖关系分析"></a>数据依赖关系分析</h3><p>可以看到并行化的for循环语句序列为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">S: c = in[i]</span><br><span class="line">T: c = c*in[i]</span><br><span class="line">U: c = c % mod</span><br><span class="line">V: out[i] = c</span><br></pre></td></tr></table></figure><p>分析出以下数据依赖关系：</p><p>$S \delta^{f}T$，$S\delta^{o}T$，$T\delta^{f}U$，$T\delta^{o}U$，$T\delta^{a}U$，$U\delta^{f}V$</p><h3 id="u5B9E_u9A8C_u7ED3_u679C_u5206_u6790"><a href="#u5B9E_u9A8C_u7ED3_u679C_u5206_u6790" class="headerlink" title="实验结果分析"></a>实验结果分析</h3><p><strong>输入：</strong>前两行为两个大素数，第三行为待加密消息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">80051</span></span><br><span class="line"><span class="number">3659</span></span><br><span class="line">Hello World! I love ParaProgramming!!!</span><br></pre></td></tr></table></figure><p> 采用OpenMP并行的rsa_omp.cpp程序的运行结果：（2线程）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Hello World! I love ParaProgramming!!!</span><br><span class="line"><span class="keyword">public</span> key: <span class="number">17113</span>, <span class="number">292906609</span></span><br><span class="line"><span class="keyword">private</span> key: <span class="number">278038877</span>, <span class="number">292906609</span></span><br><span class="line">Original text: Hello World! I love ParaProgramming!!!</span><br><span class="line">Encrypted text: <span class="number">7</span>Ԃ󿿕L&gt;ሷⷻแ႓*;&gt;&gt;&gt;</span><br><span class="line">Encrypt time is: <span class="number">6</span>ms</span><br><span class="line">Decrypted text: Hello World! I love ParaProgramming!!!</span><br><span class="line">Encrypt time is: <span class="number">100680</span>ms</span><br></pre></td></tr></table></figure><p>我们可以看到加密用时6毫秒，解密用时100680毫秒。</p><p>下面是4线程的运行结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Hello World! I love ParaProgramming!!!</span><br><span class="line"><span class="keyword">public</span> key: <span class="number">17113</span>, <span class="number">292906609</span></span><br><span class="line"><span class="keyword">private</span> key: <span class="number">278038877</span>, <span class="number">292906609</span></span><br><span class="line">Original text: Hello World! I love ParaProgramming!!!</span><br><span class="line">Encrypted text: <span class="number">7</span>Ԃ󿿕L&gt;ሷⷻแ႓*;&gt;&gt;&gt;</span><br><span class="line">Encrypt time is: <span class="number">5</span>ms</span><br><span class="line">Decrypted text: Hello World! I love ParaProgramming!!!</span><br><span class="line">Encrypt time is: <span class="number">53791</span>ms</span><br></pre></td></tr></table></figure><p>可以看到加密用时5毫秒，解密用时53791毫秒。解密用时差不多是2线程的一半时间。</p><p>下面是8线程的运行结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Hello World! I love ParaProgramming!!!</span><br><span class="line"><span class="keyword">public</span> key: <span class="number">17113</span>, <span class="number">292906609</span></span><br><span class="line"><span class="keyword">private</span> key: <span class="number">278038877</span>, <span class="number">292906609</span></span><br><span class="line">Original text: Hello World! I love ParaProgramming!!!</span><br><span class="line">Encrypted text: <span class="number">7</span>Ԃ󿿕L&gt;ሷⷻแ႓*;&gt;&gt;&gt;</span><br><span class="line">Encrypt time is: <span class="number">9</span>ms</span><br><span class="line">Decrypted text: Hello World! I love ParaProgramming!!!</span><br><span class="line">Encrypt time is: <span class="number">32144</span>ms</span><br></pre></td></tr></table></figure><p>我们看到加密用时9毫秒，解密用时32144毫秒。解密用时是4线程的60%左右。发现提高一倍的线程数已经不能带来一倍的性能提升了。主要是因为开辟线程也需要消耗一定的系统资源。</p><p>下面是串行化的RSA加解密程序运行结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Hello World! I love ParaProgramming!!!</span><br><span class="line"><span class="keyword">public</span> key: <span class="number">17113</span>, <span class="number">292906609</span></span><br><span class="line"><span class="keyword">private</span> key: <span class="number">278038877</span>, <span class="number">292906609</span></span><br><span class="line">Original text: Hello World! I love ParaProgramming!!!</span><br><span class="line">Encrypted text: <span class="number">7</span>Ԃ󿿕L&gt;ሷⷻแ႓*;&gt;&gt;&gt;</span><br><span class="line">Encrypt time is: <span class="number">11</span>ms</span><br><span class="line">Decrypted text: Hello World! I love ParaProgramming!!!</span><br><span class="line">Encrypt time is: <span class="number">201321</span>ms</span><br></pre></td></tr></table></figure><p>可以看到解密耗时201321ms，是采用2线程并行化的2倍。充分说明了并行化能显著的提升该算法的效率。</p><table><thead><tr><th style="text-align:center">串并行模式</th><th style="text-align:center">串行</th><th style="text-align:center">2线程</th><th style="text-align:center">4线程</th><th style="text-align:center">8线程</th></tr></thead><tbody><tr><td style="text-align:center">时间（毫秒）</td><td style="text-align:center">201321</td><td style="text-align:center">100680</td><td style="text-align:center">53791</td><td style="text-align:center">32144</td></tr></tbody></table><hr><h2 id="3-__u5206_u7EC4_u5B9E_u9A8C"><a href="#3-__u5206_u7EC4_u5B9E_u9A8C" class="headerlink" title="3. 分组实验"></a>3. 分组实验</h2><blockquote><p>我分配到的算法分别是17-1包含问题，20-1雅可比迭代，21-4求一般矩阵全部特征值的QR方法。</p></blockquote><h3 id="MPI_+_OpenMP"><a href="#MPI_+_OpenMP" class="headerlink" title="MPI + OpenMP"></a>MPI + OpenMP</h3><h4 id="u96C5_u53EF_u6BD4_u8FED_u4EE3"><a href="#u96C5_u53EF_u6BD4_u8FED_u4EE3" class="headerlink" title="雅可比迭代"></a>雅可比迭代</h4><p>雅可比迭代的MPI+OMP混合编程代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Compute</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    time1=MPI_Wtime();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* computing start */</span></span><br><span class="line">    <span class="keyword">while</span> (max&gt;E)                                 <span class="comment">/* The precision requirement */</span></span><br><span class="line">    &#123;</span><br><span class="line">        lmax=<span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(my_rank*m+i&lt;size)</span><br><span class="line">            &#123;</span><br><span class="line">                sum=<span class="number">0.0</span>;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">pragma</span> omp parallel for reduction( + :sum)</span></span><br><span class="line">                <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;size;j++)</span><br><span class="line">                    <span class="keyword">if</span> (j!=(my_rank*m+i))</span><br><span class="line">                        sum=sum+a(i,j)*v(j);</span><br><span class="line"></span><br><span class="line">                                                  <span class="comment">/* computes the new elements */</span></span><br><span class="line">                v1(i)=(b(i) - sum)/a(i,my_rank * m + i);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">fabs</span>(v1(i)-v(i))&gt;lmax)</span><br><span class="line">                    lmax=<span class="built_in">fabs</span>(v1(i)-v(my_rank * m + i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*Find the max element in the vector*/</span></span><br><span class="line">        MPI_Allreduce(&amp;lmax,&amp;max,<span class="number">1</span>,MPI_FLOAT,MPI_MAX,MPI_COMM_WORLD);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*Gather all the elements of the vector from all nodes*/</span></span><br><span class="line">        MPI_Allgather(v1,m,MPI_FLOAT,v,m,MPI_FLOAT,MPI_COMM_WORLD);</span><br><span class="line">        loop++;</span><br><span class="line">    &#125;                                             <span class="comment">/* while */</span></span><br><span class="line">    time2=MPI_Wtime();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到在计算中有for循环求和，因此考虑使用OMP中的reduction子句。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">pragma</span> omp parallel for reduction( + :sum)</span></span><br></pre></td></tr></table></figure><p>将for循环任务分配到各个线程中去，等计算结束之后将结果sum规约至主线程的sum中，完成并行计算。</p><p>下面是该算法的MPI实现的输出（4处理器）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Input of file <span class="string">"dataIn.txt"</span></span><br><span class="line"><span class="number">4</span><span class="number">5</span></span><br><span class="line"><span class="number">9.000000</span>-<span class="number">1.000000</span>-<span class="number">1.000000</span><span class="number">1.000000</span><span class="number">7.000000</span></span><br><span class="line"><span class="number">0.000000</span><span class="number">7.000000</span>-<span class="number">2.000000</span><span class="number">0.000000</span><span class="number">5.000000</span></span><br><span class="line">-<span class="number">3.000000</span>-<span class="number">1.000000</span><span class="number">3.000000</span>-<span class="number">1.000000</span>-<span class="number">1.000000</span></span><br><span class="line"><span class="number">1.000000</span><span class="number">1.000000</span><span class="number">1.000000</span><span class="number">9.000000</span><span class="number">3.000000</span></span><br><span class="line"></span><br><span class="line"><span class="number">0.000000</span><span class="number">0.000000</span><span class="number">1.000000</span><span class="number">0.000000</span></span><br><span class="line"></span><br><span class="line">Output of solution</span><br><span class="line">x[<span class="number">0</span>] = <span class="number">0.999969</span></span><br><span class="line">x[<span class="number">1</span>] = <span class="number">0.999960</span></span><br><span class="line">x[<span class="number">2</span>] = <span class="number">0.999932</span></span><br><span class="line">x[<span class="number">3</span>] = <span class="number">0.000031</span></span><br><span class="line"></span><br><span class="line">Iteration num = <span class="number">14</span></span><br><span class="line">Whole running time    = <span class="number">0.058200</span> seconds</span><br><span class="line">Distribute data time  = <span class="number">0.000059</span> seconds</span><br><span class="line">Parallel compute time = <span class="number">0.058141</span> seconds</span><br></pre></td></tr></table></figure><p>下面是该算法的MPI+OMP实现的输出（4处理器+4线程）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Input of file <span class="string">"dataIn.txt"</span></span><br><span class="line"><span class="number">4</span><span class="number">5</span></span><br><span class="line"><span class="number">9.000000</span>-<span class="number">1.000000</span>-<span class="number">1.000000</span><span class="number">1.000000</span><span class="number">7.000000</span></span><br><span class="line"><span class="number">0.000000</span><span class="number">7.000000</span>-<span class="number">2.000000</span><span class="number">0.000000</span><span class="number">5.000000</span></span><br><span class="line">-<span class="number">3.000000</span>-<span class="number">1.000000</span><span class="number">3.000000</span>-<span class="number">1.000000</span>-<span class="number">1.000000</span></span><br><span class="line"><span class="number">1.000000</span><span class="number">1.000000</span><span class="number">1.000000</span><span class="number">9.000000</span><span class="number">3.000000</span></span><br><span class="line"></span><br><span class="line"><span class="number">0.000000</span><span class="number">0.000000</span><span class="number">1.000000</span><span class="number">0.000000</span></span><br><span class="line"></span><br><span class="line">Output of solution</span><br><span class="line">x[<span class="number">0</span>] = <span class="number">0.999969</span></span><br><span class="line">x[<span class="number">1</span>] = <span class="number">0.999960</span></span><br><span class="line">x[<span class="number">2</span>] = <span class="number">0.999932</span></span><br><span class="line">x[<span class="number">3</span>] = <span class="number">0.000031</span></span><br><span class="line"></span><br><span class="line">Iteration num = <span class="number">14</span></span><br><span class="line">Whole running time    = <span class="number">0.000613</span> seconds</span><br><span class="line">Distribute data time  = <span class="number">0.000062</span> seconds</span><br><span class="line">Parallel compute time = <span class="number">0.000551</span> seconds</span><br></pre></td></tr></table></figure><p>可以看到整体时间缩小了100倍左右，其中都是在并行部分减少的。</p><p>经过对相同数据的测试，得到了如下的表：</p><table><thead><tr><th style="text-align:center">处理器数/线程数</th><th style="text-align:center">0</th><th style="text-align:center">2</th><th style="text-align:center">4</th><th style="text-align:center">8</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center"><font color="red">0.000014</font></td><td style="text-align:center">0.000190</td><td style="text-align:center">0.000248</td><td style="text-align:center">0.000348</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">0.000499</td><td style="text-align:center">0.000274</td><td style="text-align:center">0.000259</td><td style="text-align:center">0.005836</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">0.000086</td><td style="text-align:center">0.000218</td><td style="text-align:center">0.000519</td><td style="text-align:center">0.000320</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">0.000316</td><td style="text-align:center">0.000193</td><td style="text-align:center">0.000592</td><td style="text-align:center"><font color="green">0.109583</font></td></tr></tbody></table><p>可以看到在数据量小的情况下，增加MPI处理器数或者增加OMP线程数反而会拉低效率，因为系统开辟线程和通信也需要消耗，这一部分开销在数据量小的时候显的格外重要。</p><blockquote><p>因为找到一个较大的有解的线性方程组是比较困难的，因此没有测试该算法对较大的矩阵的效率</p></blockquote><h4 id="u5305_u542B_u95EE_u9898"><a href="#u5305_u542B_u95EE_u9898" class="headerlink" title="包含问题"></a>包含问题</h4><p>包含问题的MPI+OMP混合编程代码如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">pragma</span> omp parallel for reduction( + :mys) private(i)</span></span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n/group_size+<span class="number">1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">    mys+=cal_inter(my_rank,i,x,y); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和雅可比算法类似，也使用了reduction规约处理。</p><h3 id="MPI_u5B9E_u9A8C"><a href="#MPI_u5B9E_u9A8C" class="headerlink" title="MPI实验"></a>MPI实验</h3><h4 id="u6C42_u89E3_u4E00_u822C_u77E9_u9635_u5168_u90E8_u7279_u5F81_u503C_u7684QR_u65B9_u6CD5"><a href="#u6C42_u89E3_u4E00_u822C_u77E9_u9635_u5168_u90E8_u7279_u5F81_u503C_u7684QR_u65B9_u6CD5" class="headerlink" title="求解一般矩阵全部特征值的QR方法"></a>求解一般矩阵全部特征值的QR方法</h4><p>利用书中给的Demo，运行时会出现错误，而且选不同的处理器数量时程序结果也有区别。</p><p>下面是计算100阶矩阵的特征值的时间结果（1个处理器）：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Iteration <span class="built_in">num</span> = <span class="number">1000</span></span><br><span class="line">Whole running <span class="built_in">time</span>    = <span class="number">58.251767</span> <span class="built_in">seconds</span></span><br><span class="line">Distribute data <span class="built_in">time</span>  = <span class="number">0.017656</span> <span class="built_in">seconds</span></span><br><span class="line">Parallel compute <span class="built_in">time</span> = <span class="number">58.234111</span> <span class="built_in">seconds</span></span><br></pre></td></tr></table></figure><p>下面是计算3阶矩阵特征值的结果（3个处理器，用4个处理器得不出正确的结果）：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Iteration <span class="built_in">num</span> = <span class="number">15</span></span><br><span class="line">Whole running <span class="built_in">time</span>    = <span class="number">0.001306</span> <span class="built_in">seconds</span></span><br><span class="line">Distribute data <span class="built_in">time</span>  = <span class="number">0.000645</span> <span class="built_in">seconds</span></span><br><span class="line">Parallel compute <span class="built_in">time</span> = <span class="number">0.000662</span> <span class="built_in">seconds</span></span><br><span class="line"></span><br><span class="line"><span class="operator">the</span> envalue is</span><br><span class="line"><span class="number">7.074672</span>-<span class="number">3.187883</span>-<span class="number">0.886791</span></span><br></pre></td></tr></table></figure><p>以下是报错信息，每次计算结束后都会有该错误提示，无论结果计算是否正确。</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">=<span class="ruby">==================================================================================</span><br><span class="line"></span>=<span class="ruby">   <span class="constant">BAD</span> <span class="constant">TERMINATION</span> <span class="constant">OF</span> <span class="constant">ONE</span> <span class="constant">OF</span> <span class="constant">YOUR</span> <span class="constant">APPLICATION</span> <span class="constant">PROCESSES</span></span><br><span class="line"></span>=<span class="ruby">   <span class="constant">PID</span> <span class="number">23345</span> <span class="constant">RUNNING</span> <span class="constant">AT</span> node1</span><br><span class="line"></span>=<span class="ruby">   <span class="constant">EXIT</span> <span class="constant">CODE</span><span class="symbol">:</span> <span class="number">11</span></span><br><span class="line"></span>=<span class="ruby">   <span class="constant">CLEANING</span> <span class="constant">UP</span> <span class="constant">REMAINING</span> <span class="constant">PROCESSES</span></span><br><span class="line"></span>=<span class="ruby">   <span class="constant">YOU</span> <span class="constant">CAN</span> <span class="constant">IGNORE</span> <span class="constant">THE</span> <span class="constant">BELOW</span> <span class="constant">CLEANUP</span> <span class="constant">MESSAGES</span></span><br><span class="line"></span>=<span class="ruby">==================================================================================</span><br><span class="line"></span>YOUR APPLICATION TERMINATED WITH THE EXIT STRING: Segmentation fault (signal 11)</span><br><span class="line">This typically refers to a problem with your application.</span><br><span class="line">Please see the FAQ page for debugging suggestions</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是研一课程《并行程序设计》的实验报告&lt;/p&gt;
    
    </summary>
    
    
      <category term="MPI" scheme="https://www.kingnop.club/tags/MPI/"/>
    
      <category term="OpenMP" scheme="https://www.kingnop.club/tags/OpenMP/"/>
    
      <category term="Parallel programming" scheme="https://www.kingnop.club/tags/Parallel-programming/"/>
    
  </entry>
  
  <entry>
    <title>Markdown的介绍</title>
    <link href="https://www.kingnop.club/2018/12/24/markdown%E7%9A%84%E4%BB%8B%E7%BB%8D/"/>
    <id>https://www.kingnop.club/2018/12/24/markdown的介绍/</id>
    <published>2018-12-24T08:24:00.000Z</published>
    <updated>2018-12-24T08:26:21.620Z</updated>
    
    <content type="html"><![CDATA[<p>关于Markdown语法的介绍。</p><a id="more"></a><h1 id="u4F7F_u7528Markdown_u7ED9_u4F60_u5E26_u6765_u6C89_u6D78_u5F0F_u5199_u4F5C_u4F53_u9A8C"><a href="#u4F7F_u7528Markdown_u7ED9_u4F60_u5E26_u6765_u6C89_u6D78_u5F0F_u5199_u4F5C_u4F53_u9A8C" class="headerlink" title="使用Markdown给你带来沉浸式写作体验"></a>使用Markdown给你带来沉浸式写作体验</h1><h2 id="Markdown_u662F_u4EC0_u4E48"><a href="#Markdown_u662F_u4EC0_u4E48" class="headerlink" title="Markdown是什么"></a>Markdown是什么</h2><p>Markdown是目前互联网上最流行的<font color="red">写作语言</font>，它使用一些简单的符号（* / ` &gt; [] () #）来标记文本，使文本具有一定的格式。</p><p>维基百科中对Markdown的描述如下：</p><blockquote><p>Markdown是一种轻量级标记语言，创始人为约翰·格鲁伯。它允许人们“使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML（或者HTML）文档”。这种语言吸收了很多在电子邮件中已有的纯文本标记的特性。</p><p>由于Markdown的轻量化，易读易写特性，并且对于图片，图表，数学式都有支援，目前许多网站都广泛使用Markdown来撰写说明文件或是用于论坛上发表讯息。例如：GitHub，reddit， Diaspora，Stack Exchange，OpenStreetMap，Source Forge等。甚至Markdown能被使用来撰写电子书。</p></blockquote><h2 id="Markdown_u7684_u4F18_u52BF"><a href="#Markdown_u7684_u4F18_u52BF" class="headerlink" title="Markdown的优势"></a>Markdown的优势</h2><ul><li><p>易写</p><p>Markdown<font color="red">语法十分简单</font>，常用的标记符号不超过十个。用于日常写作记录绰绰有余。但这十个不到的标记符号，却能让人优雅地沉浸式写作，专注内容而不纠结排版，像写代码一样写文档，大大提高书写效率。</p></li><li><p>易读</p><ul><li><p>「什么人都能打开」</p><blockquote><p>所谓「什么人都能打开」是指Markdown属于纯文本，可以用任何的文本编辑器打开编辑。避免了有时候无法打开Word或者Pages等情况的发生。Markdown文本也可以轻松的转换成PDF，HTML等格式。</p></blockquote></li><li><p>「排版样式不变」</p><blockquote><p>所谓「排版样式不变」是指在转化为富文本或HTML等格式后，依然可以保留原文的排版不变。避免了Word有时候会发生版本不一致导致的排版不一致的情况发生。</p></blockquote></li></ul></li><li><p>沉浸式书写</p><p>与Latex类似，可以在书写时专注于书写的内容而不必担心格式的问题，避免打乱书写思路。</p></li><li><p>排版美观且可以自定义</p><p>默认排版已经比较优雅和美观。如果不满意也可以自行修改配置文件来达到期望的排版，灵活性强。</p></li><li><p>支持软件丰富</p><p>不管是Windows或者Mac系统，甚至网页，iOS和Android都有支持Markdown的软件。支持Markdown语法的笔记类工具也非常多，例如为知笔记，网易云笔记和印象笔记等。</p></li></ul><font color="red">Markdown不是为了取代Word，也不能够取代Word。但是可以为用户提供一个沉浸式的，不受格式困扰的写作环境。在有些情况下是非常高效的。</font><h2 id="Markdown_u7684_u9002_u7528_u573A_u666F"><a href="#Markdown_u7684_u9002_u7528_u573A_u666F" class="headerlink" title="Markdown的适用场景"></a>Markdown的适用场景</h2><ul><li>日记书写，快速排版编辑</li><li>程序员</li><li>做课堂笔记</li><li>TODO List</li><li>…</li></ul><h2 id="Markdown_u7684_u8BED_u6CD5_u4ECB_u7ECD"><a href="#Markdown_u7684_u8BED_u6CD5_u4ECB_u7ECD" class="headerlink" title="Markdown的语法介绍"></a>Markdown的语法介绍</h2><h4 id="u6807_u9898"><a href="#u6807_u9898" class="headerlink" title="标题"></a>标题</h4><p>Markdown支持6种级别的标题</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># h1</span><br><span class="line">## h2</span><br><span class="line">### h3</span><br><span class="line">#### h4</span><br><span class="line">##### h5</span><br><span class="line">###### h6</span><br></pre></td></tr></table></figure><p>对应的效果如下：</p><h1 id="h1"><a href="#h1" class="headerlink" title="h1"></a>h1</h1><h2 id="h2"><a href="#h2" class="headerlink" title="h2"></a>h2</h2><h3 id="h3"><a href="#h3" class="headerlink" title="h3"></a>h3</h3><h4 id="h4"><a href="#h4" class="headerlink" title="h4"></a>h4</h4><h5 id="h5"><a href="#h5" class="headerlink" title="h5"></a>h5</h5><h6 id="h6"><a href="#h6" class="headerlink" title="h6"></a>h6</h6><hr><h4 id="u6BB5_u843D_u53CA_u533A_u5757_u5F15_u7528"><a href="#u6BB5_u843D_u53CA_u533A_u5757_u5F15_u7528" class="headerlink" title="段落及区块引用"></a>段落及区块引用</h4><p>使用Markdown分段只需要将需要分段的内容前后保留至少一个空行即可。</p><p>Markdown提供了一个特殊符号&gt;用于块引用</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; 这段文字是引用</span><br></pre></td></tr></table></figure><blockquote><p>这段文字是引用</p></blockquote><hr><h4 id="u63D2_u5165_u94FE_u63A5_uFF0C_u811A_u6CE8_u548C_u56FE_u7247"><a href="#u63D2_u5165_u94FE_u63A5_uFF0C_u811A_u6CE8_u548C_u56FE_u7247" class="headerlink" title="插入链接，脚注和图片"></a>插入链接，脚注和图片</h4><p>Markdown针对链接和图片的处理也很简单，使用如下语法进行标记</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[点击跳转到Bing](https://cn.bing.com/)</span><br><span class="line">![美丽的风景](<span class="keyword">C</span>:\Users\kingn\Desktop\研一课程\文献管理\<span class="number">1.</span>jpg)</span><br></pre></td></tr></table></figure><p><a href="https://cn.bing.com/" target="_blank" rel="external">点击跳转到Bing</a></p><p><img src="C:\Users\kingn\Desktop\研一课程\文献管理\1.jpg" alt="1"></p><p>可以看到超链接和图片的唯一区别就是在前面多了一个感叹号。图片地址可以是一个本地的地址，也可以是网络上的地址。</p><p>使用<code>[^keyword]</code>来表示脚注</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这是一个脚注<span class="string">[^f1]</span>的样例。</span><br><span class="line">这是另一个脚注<span class="string">[^f2]</span>的样例。</span><br></pre></td></tr></table></figure><p>这是一个脚注[^f1]的样例。<br>这是另一个脚注[^f2]的样例。</p><hr><h4 id="u5217_u8868"><a href="#u5217_u8868" class="headerlink" title="列表"></a>列表</h4><p>Markdown支持有序列表和无序列表两种形式</p><ul><li><p>无序列表用*或+或-标识</p></li><li><p>有序列表用数字表示</p></li></ul><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+ 雪碧</span><br><span class="line">+ 可乐</span><br><span class="line"></span><br><span class="line">- 雪碧</span><br><span class="line">- 可乐</span><br><span class="line"></span><br><span class="line">* 雪碧</span><br><span class="line">* 可乐</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 雪碧</span><br><span class="line"><span class="number">2.</span> 可乐</span><br></pre></td></tr></table></figure><p>以上标记效果如下</p><ul><li>雪碧</li><li>可乐</li></ul><ul><li>雪碧</li><li>可乐</li></ul><ul><li>雪碧</li><li>可乐</li></ul><ol><li>雪碧</li><li>可乐</li></ol><hr><h4 id="u5206_u5272_u7EBF"><a href="#u5206_u5272_u7EBF" class="headerlink" title="分割线"></a>分割线</h4><p>有时候为了排版漂亮会加入分割线，可以用下面的方法加入</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br></pre></td></tr></table></figure><hr><hr><h4 id="u5F3A_u8C03"><a href="#u5F3A_u8C03" class="headerlink" title="强调"></a>强调</h4><p>有时候需要对某一部分内容进行强调或者用删除线划去。用一对<em>或者_包裹的为斜体，用两对\</em>或者_包裹的为强调，用~~包裹的为删除线。</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*这里是斜体*</span><br><span class="line">_这里也是斜体_</span><br><span class="line"></span><br><span class="line">**这里是加粗**</span><br><span class="line">__这里也是加粗__</span><br><span class="line"></span><br><span class="line">~~这里是删除~~</span><br></pre></td></tr></table></figure><p><em>这里是斜体</em><br><em>这里也是斜体</em></p><p><strong>这里是加粗</strong><br><strong>这里也是加粗</strong></p><p><del>这里是删除</del></p><hr><h4 id="u63D2_u5165_u4EE3_u7801_u53CA_u4EE3_u7801_u5757"><a href="#u63D2_u5165_u4EE3_u7801_u53CA_u4EE3_u7801_u5757" class="headerlink" title="插入代码及代码块"></a>插入代码及代码块</h4><p>Markdown可以轻松优雅的插入代码块。如果是行内引用，只需要用单个反引号包裹；如果是代码块，则使用两个以上反引号包裹。</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">这是一段`int a = b;`行内代码</span><br><span class="line"></span><br><span class="line">​```<span class="keyword">C</span></span><br><span class="line">#includ &lt;stdio.h&gt;</span><br><span class="line">int main()</span><br><span class="line"><span class="list">&#123;</span><br><span class="line">    int a=0;</span><br><span class="line">    print("%d", a);</span><br><span class="line">&#125;</span></span><br><span class="line">​</span><br></pre></td></tr></table></figure><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">这是一段<span class="escape">`i</span>nt <span class="literal">a</span> = b<span class="comment">;`行内代码</span></span><br><span class="line"></span><br><span class="line"><span class="escape">``</span><span class="escape">`C</span></span><br><span class="line">#includ &lt;stdio.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int <span class="literal">a</span>=<span class="number">0</span><span class="comment">;</span></span><br><span class="line">    print(<span class="string">"%d"</span>, <span class="literal">a</span>)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Markdown会自动识别代码段中的语言并进行关键词高亮，你也可以在最上方的反引号后输入语言名称来指定关键词高亮方式。</p><hr><h4 id="u63D2_u5165_u8868_u683C"><a href="#u63D2_u5165_u8868_u683C" class="headerlink" title="插入表格"></a>插入表格</h4><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">表头|条目一|条目二</span><br><span class="line"><span class="symbol">:---</span><span class="symbol">:|</span><span class="symbol">:---</span><span class="symbol">:|</span><span class="symbol">:---</span><span class="symbol">:</span></span><br><span class="line">项目|项目一|项目二</span><br></pre></td></tr></table></figure><p>以上代码产生了如下的表格</p><table><thead><tr><th style="text-align:center">表头</th><th style="text-align:center">条目一</th><th style="text-align:center">条目二</th></tr></thead><tbody><tr><td style="text-align:center">项目</td><td style="text-align:center">项目一</td><td style="text-align:center">项目二</td></tr></tbody></table><p>三个短斜杠左右的冒号用于控制对齐方式，只放置左边冒号表示文字居左，只放置右边冒号表示文字居右，如果两边都放置冒号表示文字居中。</p><hr><h4 id="u7279_u6B8A_u7B26_u53F7_u5904_u7406"><a href="#u7279_u6B8A_u7B26_u53F7_u5904_u7406" class="headerlink" title="特殊符号处理"></a>特殊符号处理</h4><p>如果需要输入Markdown保留的特殊符号，则需要用转义字符反斜杠\将字符转义。主要有以下几种符号需要转义</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">\   反斜线</span><br><span class="line">`   反引号</span><br><span class="line">*   星号</span><br><span class="line">_   底线</span><br><span class="line"><span class="list">&#123;&#125;</span>  花括号</span><br><span class="line">[]  方括号</span><br><span class="line">()  括弧</span><br><span class="line">#   井字号</span><br><span class="line">+   加号</span><br><span class="line">-   减号</span><br><span class="line">.   英文句点</span><br><span class="line">!   惊叹号</span><br></pre></td></tr></table></figure><p>注：在内容中输入以上特殊符号的时候一定要注意转义，否则将导致内容显示不全，甚至排版混乱。</p><hr><h4 id="TODO_List"><a href="#TODO_List" class="headerlink" title="TODO List"></a>TODO List</h4><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby"> [ ] 大项目</span><br><span class="line"></span>  -<span class="ruby"> [ ] 首先</span><br><span class="line"></span>  -<span class="ruby"> [x] 然后</span><br><span class="line"></span>  -<span class="ruby"> [ ] 最后</span><br><span class="line"></span></span><br><span class="line">-<span class="ruby"> [x] 另一项大项目</span></span><br></pre></td></tr></table></figure><ul><li><p>[ ] 大项目</p><ul><li>[ ] 首先</li><li>[x] 然后</li><li>[ ] 最后</li></ul></li><li><p>[x] 另一项大项目</p></li></ul><hr><h4 id="u76EE_u5F55"><a href="#u76EE_u5F55" class="headerlink" title="目录"></a>目录</h4><p>在需要插入目录的地方输入<code>[TOC]</code>，会自动根据输入的标题级别创建目录。</p><p>这个目录是自动更新的。</p><p>[TOC]</p><hr><h4 id="u6D41_u7A0B_u56FE"><a href="#u6D41_u7A0B_u56FE" class="headerlink" title="流程图"></a>流程图</h4><p>流程图的创建使用flow语法。</p><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">​```flow</span><br><span class="line">st=&gt;start: <span class="type">Start</span></span><br><span class="line">e=&gt;<span class="keyword">end</span>: <span class="type">End</span></span><br><span class="line"><span class="keyword">op</span>=&gt;operation: <span class="type">My</span> <span class="type">Operation</span></span><br><span class="line">cond=&gt;condition:<span class="type">Yes</span> or <span class="type">No</span>?</span><br><span class="line"></span><br><span class="line">st-&gt;<span class="keyword">op</span>-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;<span class="keyword">op</span></span><br><span class="line">​</span><br></pre></td></tr></table></figure><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```flow</span><br><span class="line">st=&gt;start: <span class="type">Start</span></span><br><span class="line">e=&gt;<span class="keyword">end</span>: <span class="type">End</span></span><br><span class="line"><span class="keyword">op</span>=&gt;operation: <span class="type">My</span> <span class="type">Operation</span></span><br><span class="line">cond=&gt;condition: <span class="type">Yes</span> or <span class="type">No</span>?</span><br><span class="line"></span><br><span class="line">st-&gt;<span class="keyword">op</span>-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;<span class="keyword">op</span></span><br></pre></td></tr></table></figure><p>使用起来也比较简单，分为两部分，上半部分是创建元素的过程，下半部分为定义元素的走向。</p><p>除此之外，还可以使用Mermaid来创建流程图，状态图，时序图和甘特图等。具体使用还需要参照Mermaid的语法来进行。需要注意的是不是所有的Markdown编辑器都支持Mermaid语法。</p><hr><h4 id="u516C_u5F0F"><a href="#u516C_u5F0F" class="headerlink" title="公式"></a>公式</h4><p>Markdown支持LaTeX公式，符合LxTeX语法的公式可以直接嵌入在Markdown文本中。与嵌入代码类似，公式也分为行内公式和公式块。行内公式用\$包裹起来，公式块用\$\$包裹。</p><figure class="highlight parser3"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">质能方程：</span><span class="variable">$E</span><span class="xml">=mc</span><span class="keyword">^2</span><span class="xml">$，这个方程展示了行内公式。</span><br><span class="line"></span><br><span class="line">下面展示了公式块。</span><br><span class="line">$$</span><br><span class="line">f(x_1,x_2,\idots ,x_n)=x_1</span><span class="keyword">^2</span><span class="xml">+x_2</span><span class="keyword">^2</span><span class="xml">+\cdots +x_n</span><span class="keyword">^2</span><span class="xml"></span><br><span class="line">$$</span></span><br></pre></td></tr></table></figure><p>质能方程：$E=mc^2$，这个方程展示了行内公式。</p><p>下面展示了公式块。<br>$$<br>f(x_1,x_2,\dots ,x_n)=x_1^2+x_2^2+\cdots +x_n^2<br>$$</p><hr><h4 id="HTML_u652F_u6301"><a href="#HTML_u652F_u6301" class="headerlink" title="HTML支持"></a>HTML支持</h4><p>Markdown中支持html语句的直接嵌入。如果熟悉html的话，可以直接在编辑过程中使用html标签。</p><hr><h2 id="Markdown_u8F6F_u4EF6_u63A8_u8350"><a href="#Markdown_u8F6F_u4EF6_u63A8_u8350" class="headerlink" title="Markdown软件推荐"></a>Markdown软件推荐</h2><ul><li><p>Windows</p><ul><li>Typora</li><li>Visual Studio Code</li><li>Cmd Markdown</li></ul></li><li><p>MacOs</p><ul><li>Ulysses</li><li>Typora</li><li>Mou</li></ul></li><li><p>笔记软件</p><ul><li>印象笔记</li><li>为知笔记</li><li>网易云笔记</li><li>简书</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于Markdown语法的介绍。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Markdown" scheme="https://www.kingnop.club/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>Linux下手动安装Python3</title>
    <link href="https://www.kingnop.club/2018/11/27/%E6%89%8B%E5%8A%A8%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85python%E7%8E%AF%E5%A2%83/"/>
    <id>https://www.kingnop.club/2018/11/27/手动编译安装python环境/</id>
    <published>2018-11-27T07:08:00.000Z</published>
    <updated>2018-11-27T10:36:12.325Z</updated>
    
    <content type="html"><![CDATA[<p>在某些情况下不能使用包管理软件直接安装Python，此时可以通过手动编译安装的方式成功安装</p><a id="more"></a><h1 id="u4E8B_u5148_u51C6_u5907"><a href="#u4E8B_u5148_u51C6_u5907" class="headerlink" title="事先准备"></a>事先准备</h1><p>从<a href="www.python.org">Python的官网</a>下载Python的Linux版本安装版，安装包以.tar或.xz结尾</p><p>将安装压缩包拷贝到需要安装的机器中</p><p>确保拥有该机器的管理员权限</p><h1 id="u64CD_u4F5C"><a href="#u64CD_u4F5C" class="headerlink" title="操作"></a>操作</h1><p>首先对安装包进行解压缩</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xz <span class="operator">-d</span> Python-<span class="number">3.6</span>.<span class="number">1</span>.tar.xz</span><br><span class="line">tar -xvf Python-<span class="number">3.6</span>.<span class="number">1</span>.tar</span><br></pre></td></tr></table></figure><p>然后执行相应的配置文件</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure</span><br></pre></td></tr></table></figure><p>然后执行用make进行编译</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make&#10;make install</span><br></pre></td></tr></table></figure><p>最后用ln命令建立软链接即可实现直接输入python启动python环境</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s /usr/local/bin/python3 /usr/bin/python</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在某些情况下不能使用包管理软件直接安装Python，此时可以通过手动编译安装的方式成功安装&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.kingnop.club/tags/Linux/"/>
    
      <category term="Python3" scheme="https://www.kingnop.club/tags/Python3/"/>
    
  </entry>
  
  <entry>
    <title>Python实现主机间全双工通信及文件发送</title>
    <link href="https://www.kingnop.club/2018/11/27/Python%E5%85%A8%E5%8F%8C%E5%B7%A5%E9%80%9A%E4%BF%A1/"/>
    <id>https://www.kingnop.club/2018/11/27/Python全双工通信/</id>
    <published>2018-11-27T06:12:00.000Z</published>
    <updated>2018-11-27T06:45:33.255Z</updated>
    
    <content type="html"><![CDATA[<p>本程序是信息网络与协议课程的一个作业。利用Socket编程和多线程技术实现了两个主机之间的IPv6通信和文件传输。</p><p>代码在ArchLinux系统下测试通过。</p><a id="more"></a><h1 id="u5B9E_u73B0_u529F_u80FD"><a href="#u5B9E_u73B0_u529F_u80FD" class="headerlink" title="实现功能"></a>实现功能</h1><p>代码实现了主机间的全双工通信以及文件传输功能</p><h1 id="u539F_u7406"><a href="#u539F_u7406" class="headerlink" title="原理"></a>原理</h1><p>通过开辟额外的线程执行socket通信中的recv()操作，避免了在一个线程中send()和recv()操作会相互阻塞的情况发生，实现了全双工的功能。</p><h1 id="u4E0D_u8DB3"><a href="#u4E0D_u8DB3" class="headerlink" title="不足"></a>不足</h1><ol><li>由于是实验作业，所以没有完全考虑到输入合法性的问题。实际应用中应该完全考虑到过滤非法输入。</li><li>如果要实现多方通信或群聊等功能，最好还是独立出一个服务器。</li><li>异常退出时有时候没有关闭套接字。导致下次bind时发生错误。</li><li>如何从子线程中正常的关闭主线程还是一个待解决的问题。</li></ol><h1 id="u4EE3_u7801_u53CA_u89E3_u91CA"><a href="#u4EE3_u7801_u53CA_u89E3_u91CA" class="headerlink" title="代码及解释"></a>代码及解释</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># @Author  : Wyf</span></span><br><span class="line"><span class="comment"># @Time    : 2018/11/25</span></span><br><span class="line"><span class="comment"># @Function: ipv6 socket communication</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">MAX_BUFF = <span class="number">1024</span>         <span class="comment"># 最大缓冲区空间为1024字节</span></span><br><span class="line">DEFAULT_PORT = <span class="number">32768</span>    <span class="comment"># 默认的服务器连接端口为32768</span></span><br><span class="line">isworkFlag = <span class="keyword">False</span>      <span class="comment"># 是否继续工作标志位，用于退出时使用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> isworkFlag</span><br><span class="line">    <span class="keyword">print</span> (<span class="string">"Time:"</span>, (time.strftime(<span class="string">"%Y-%m-%d %H:%M:%S"</span>, time.localtime()))) <span class="comment"># 打印当前时间</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        host, port = input(<span class="string">"Please enter target IP and Port: "</span>).split()     <span class="comment"># 用户输入目标ip地址和端口号，如果不输入则默认为服务器端</span></span><br><span class="line">        flag = <span class="string">"ClientMode"</span> <span class="comment"># 如果没有捕捉到异常证明输入了内容，启动客户端</span></span><br><span class="line">    <span class="keyword">except</span> ValueError:</span><br><span class="line">        flag = <span class="string">"ServerMode"</span> <span class="comment"># 否则启动服务器</span></span><br><span class="line">    <span class="keyword">if</span> flag == <span class="string">"ClientMode"</span>: <span class="comment"># 以下为客户端进行操作</span></span><br><span class="line">        print_green (<span class="string">"ClientMode..."</span>)</span><br><span class="line">        <span class="keyword">print</span> (<span class="string">"Connecting to &#123;0&#125;  port &#123;1&#125;"</span>.format(host, port))</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            client = socket.socket(socket.AF_INET6, socket.SOCK_STREAM, <span class="number">0</span>) <span class="comment"># 创建IPv6套接字，TCP连接</span></span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            print_red (<span class="string">"Fail to create socket..."</span>)</span><br><span class="line">            exit(-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            client.connect((host, int(port))) <span class="comment"># 连接到指定的主机</span></span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            print_red (<span class="string">"Fail to connect to host..."</span>)</span><br><span class="line">            exit(-<span class="number">2</span>)</span><br><span class="line">        print_green (<span class="string">"Connected successful, now you can chat !"</span>)</span><br><span class="line">        isworkFlag = <span class="keyword">True</span> <span class="comment"># 连接成功，将标志位置为True</span></span><br><span class="line">        t = threading.Thread(target= receiveMsg, args= (client, )) <span class="comment"># 创建子线程，子线程执行receiveMsg函数，参数为套接字client</span></span><br><span class="line">        t.setDaemon(<span class="keyword">True</span>) <span class="comment"># 设置该线程为守护线程，当主线程退出时该线程无条件退出</span></span><br><span class="line">        t.start() <span class="comment"># 启动子线程，启动数据接收</span></span><br><span class="line">        <span class="keyword">while</span> isworkFlag: <span class="comment"># 以下为客户端输入，只要工作标志位为True就一直执行循环</span></span><br><span class="line">            msg = input() <span class="comment"># 接收用户输入</span></span><br><span class="line">            client.send(msg.encode(<span class="string">'utf-8'</span>)) <span class="comment"># 将输入的str类型字符串转换为可供传输的byte类型</span></span><br><span class="line">            <span class="keyword">if</span> msg == <span class="string">"END"</span>: <span class="comment"># 如果输入的消息是‘END’，则将工作标志位置为False</span></span><br><span class="line">                isworkFlag = <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">if</span> msg == <span class="string">"FILE"</span>:<span class="comment"># 如果输入的消息是‘FILE’，则调用sendFile函数进行文件传送</span></span><br><span class="line">                sendFile(client)</span><br><span class="line">        client.close() <span class="comment"># 退出时关闭套接字</span></span><br><span class="line">        print_red (<span class="string">"Connection Closed..."</span>)</span><br><span class="line">        exit(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">elif</span> flag == <span class="string">"ServerMode"</span>: <span class="comment"># 进入服务器模式</span></span><br><span class="line">        host = str(getHostIpv6Addr()) <span class="comment"># 获取本机的ipv6地址</span></span><br><span class="line">        port = DEFAULT_PORT <span class="comment"># 采用设定好的端口</span></span><br><span class="line">        print_green (<span class="string">"ServerMode..."</span>)</span><br><span class="line">        print_green (<span class="string">"Your IPV6 address is &#123;0&#125;, port is &#123;1&#125;"</span>.format(host, port))</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            server = socket.socket(socket.AF_INET6, socket.SOCK_STREAM, <span class="number">0</span>) <span class="comment"># 服务器创建套接字</span></span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            print_red (<span class="string">"Fail to create socket..."</span>)</span><br><span class="line">            exit(-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            server.bind((host, port)) <span class="comment"># 与本机指定的ipv6地址和端口进行绑定</span></span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            print_red (<span class="string">"Fail to bind..."</span>)</span><br><span class="line">            exit(-<span class="number">3</span>)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            server.listen(<span class="number">5</span>) <span class="comment"># 监听套接字</span></span><br><span class="line">            <span class="keyword">print</span> (<span class="string">"Waiting Connection..."</span>)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            print_red (<span class="string">"Fail to listen connection"</span>)</span><br><span class="line">            exit(-<span class="number">4</span>)</span><br><span class="line">        clientsocket, clientaddr = server.accept() <span class="comment"># 接收客户端的连接请求</span></span><br><span class="line">        print_green (<span class="string">"Connected. Target Ip is &#123;0&#125;"</span>.format(clientaddr))</span><br><span class="line">        isworkFlag = <span class="keyword">True</span> <span class="comment"># 连接创建后将工作标志设定为True</span></span><br><span class="line">        server.close() <span class="comment"># 关闭服务端套接字，之后收发消息使用接收客户端连接创建的套接字</span></span><br><span class="line">        t = threading.Thread(target= receiveMsg, args= (clientsocket, )) <span class="comment"># 创建子线程，执行receiveMsg函数，等待接收消息</span></span><br><span class="line">        t.setDaemon(<span class="keyword">True</span>) <span class="comment"># 设置线程为守护线程</span></span><br><span class="line">        t.start() <span class="comment"># 启动线程</span></span><br><span class="line">        <span class="keyword">while</span> isworkFlag: <span class="comment"># 当工作标志为True时一直执行以下语句</span></span><br><span class="line">            msg = input() <span class="comment"># 接收用户输入</span></span><br><span class="line">            clientsocket.send(msg.encode(<span class="string">'utf-8'</span>)) <span class="comment"># 将用户输入的str类型字符串转换为byte类型后发送</span></span><br><span class="line">            <span class="keyword">if</span> msg == <span class="string">"END"</span>: <span class="comment"># 如果收到‘END’后，则将标志位置为False</span></span><br><span class="line">                isworkFlag = <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">if</span> msg == <span class="string">"FILE"</span>:<span class="comment"># 如果收到‘FILE’后，则执行sendFile函数，启动文件传输</span></span><br><span class="line">                sendFile(clientsocket)</span><br><span class="line">        clientsocket.close() <span class="comment">#关闭套接字</span></span><br><span class="line">        server.close()</span><br><span class="line">        print_red (<span class="string">"Connection Closed..."</span>)</span><br><span class="line">        exit(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">print</span> (<span class="string">"Wrong input"</span>)</span><br><span class="line">        exit()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">receiveMsg</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> isworkFlag <span class="comment"># 工作标志位为全局变量</span></span><br><span class="line">    <span class="keyword">while</span> isworkFlag: <span class="comment"># 当工作标志位为False时退出</span></span><br><span class="line">        msg = s.recv(MAX_BUFF) <span class="comment"># 接收数据，缓冲区为设置的大小</span></span><br><span class="line">        print_green (msg.decode(<span class="string">'utf-8'</span>)) <span class="comment"># 显示消息</span></span><br><span class="line">        <span class="keyword">if</span> msg.decode(<span class="string">'utf-8'</span>) == <span class="string">'END'</span>: <span class="comment"># 如果接收到的消息为‘END’，则将标志位设置为False，关闭套接字，关闭程序</span></span><br><span class="line">            isworkFlag = <span class="keyword">False</span></span><br><span class="line">            s.close()</span><br><span class="line">            print_red (<span class="string">"Connection Closed..."</span>)</span><br><span class="line">            os._exit(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> msg.decode(<span class="string">'utf-8'</span>) == <span class="string">'FILE'</span>: <span class="comment"># 如果接收到的消息为‘FILE’，则证明需要接收文件</span></span><br><span class="line">            data = s.recv(MAX_BUFF) <span class="comment"># 接收文件内容前首先接收文件名和文件大小的信息</span></span><br><span class="line">            filename, filesize = data.decode(<span class="string">'utf-8'</span>).split(<span class="string">'|'</span>) <span class="comment"># 分离文件名和文件大小</span></span><br><span class="line">            filepath = os.path.join(os.path.dirname(os.path.abspath(__file__)), filename) <span class="comment"># 将文件路径指定为当前目录</span></span><br><span class="line">            filesize = int(filesize) <span class="comment"># 转为int类型</span></span><br><span class="line">            has_sent = <span class="number">0</span> <span class="comment"># 已经接受的数据大小</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">with</span> open(filepath, <span class="string">'wb'</span>) <span class="keyword">as</span> fp: <span class="comment"># 在当前目录创建同名文件并打开</span></span><br><span class="line">                <span class="keyword">while</span> has_sent != filesize: <span class="comment"># 如果没有接受完数据</span></span><br><span class="line">                    data = s.recv(MAX_BUFF) <span class="comment"># 接收文件内容</span></span><br><span class="line">                    fp.write(data) <span class="comment"># 将数据写入文件</span></span><br><span class="line">                    has_sent = has_sent + len(data) <span class="comment"># 更改已接受的数据大小</span></span><br><span class="line">                    <span class="keyword">print</span> (<span class="string">'\r'</span> + <span class="string">'[Saving]:%s%.02f%%'</span> % (<span class="string">'&gt;'</span> * int((has_sent / filesize) * <span class="number">50</span>), float(has_sent / filesize) * <span class="number">100</span>), end=<span class="string">''</span>) <span class="comment"># 显示进度条</span></span><br><span class="line">            print(<span class="string">"\n%s is saved."</span> % filename) <span class="comment"># 接收完毕后提示</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getHostIpv6Addr</span><span class="params">()</span>:</span> <span class="comment"># Only works in Linux</span></span><br><span class="line">    getIPV6_process = subprocess.Popen([<span class="string">"cat"</span>, <span class="string">"/proc/net/if_inet6"</span>], stdout = subprocess.PIPE) <span class="comment"># 相当于在系统中执行cat /proc/net/if_inet6 而ipv6地址存放在该文件中</span></span><br><span class="line">    output = getIPV6_process.stdout.read() <span class="comment"># 读出返回数据</span></span><br><span class="line">    ipv6_pattern = <span class="string">'(2001+[a-f0-9]&#123;28&#125;)'</span> <span class="comment"># match IPV6 address 匹配global ipv6地址的正则表达式</span></span><br><span class="line">    m = re.search(ipv6_pattern, output.decode(<span class="string">'utf-8'</span>)) <span class="comment"># 在输出的内容中匹配符合条件的字符串，即为ipv6地址</span></span><br><span class="line">    ori_ipv6 = m.group() <span class="comment"># 取出该地址</span></span><br><span class="line">    <span class="comment"># 标准化该地址，添加:</span></span><br><span class="line">    aft_ipv6 = ori_ipv6[<span class="number">0</span>:<span class="number">4</span>] + <span class="string">':'</span> + ori_ipv6[<span class="number">4</span>:<span class="number">8</span>] + <span class="string">':'</span> + ori_ipv6[<span class="number">8</span>:<span class="number">12</span>] + <span class="string">':'</span> + ori_ipv6[<span class="number">12</span>:<span class="number">16</span>] +<span class="string">':'</span> +ori_ipv6[<span class="number">16</span>:<span class="number">20</span>] + <span class="string">':'</span> + ori_ipv6[<span class="number">20</span>:<span class="number">24</span>] + <span class="string">':'</span> + ori_ipv6[<span class="number">24</span>:<span class="number">28</span>] + <span class="string">':'</span> + ori_ipv6[<span class="number">28</span>:<span class="number">32</span>]</span><br><span class="line">    <span class="keyword">return</span> aft_ipv6</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sendFile</span><span class="params">(s)</span>:</span> <span class="comment"># 传送文件的函数</span></span><br><span class="line">    filepath = input(<span class="string">"Input File Path: "</span>).strip() <span class="comment"># 用户输入路径，去掉输入的空格</span></span><br><span class="line">    filename = os.path.basename(filepath) <span class="comment"># 获取文件名</span></span><br><span class="line">    filesize = os.stat(filepath).st_size <span class="comment"># 获取文件大小 字节数</span></span><br><span class="line">    fileinfo = <span class="string">"%s|%s"</span> % (filename, filesize) <span class="comment"># 将文件信息整合为 &#123;文件名|文件大小&#125; 的形式发送给接收端</span></span><br><span class="line">    s.send(fileinfo.encode(<span class="string">'utf-8'</span>)) <span class="comment"># 发送文件信息</span></span><br><span class="line"></span><br><span class="line">    has_sent = <span class="number">0</span> <span class="comment"># 已发送的大小</span></span><br><span class="line">    <span class="keyword">with</span> open(filepath, <span class="string">'rb'</span>) <span class="keyword">as</span> fp: <span class="comment"># 打开文件</span></span><br><span class="line">        <span class="keyword">while</span> has_sent != filesize: <span class="comment"># 如果没有发送完</span></span><br><span class="line">            data = fp.read(MAX_BUFF) <span class="comment"># 读取文件 最大1024字节</span></span><br><span class="line">            s.sendall(data) <span class="comment"># 发送全部数据 其实此处使用send函数也是一样的 因为已经限定了data的大小最大为1024个字节 远小于MTU</span></span><br><span class="line">            has_sent = has_sent + len(data) <span class="comment"># 更改已发送的数据大小</span></span><br><span class="line">            <span class="keyword">print</span> (<span class="string">'\r'</span> + <span class="string">'[Sending]:%s%.02f%%'</span> % (<span class="string">'&gt;'</span> * int((has_sent / filesize) * <span class="number">50</span>), float(has_sent / filesize) * <span class="number">100</span>), end=<span class="string">''</span>)</span><br><span class="line">    print(<span class="string">"\n%s is sent to other"</span> % filename)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_red</span><span class="params">(s)</span>:</span> <span class="comment"># 终端中显示红色字</span></span><br><span class="line">    fuck = <span class="string">'\033[31m'</span> + s + <span class="string">'\033[0m'</span></span><br><span class="line">    <span class="keyword">print</span> (fuck)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_green</span><span class="params">(s)</span>:</span> <span class="comment"># 终端中显示绿色字</span></span><br><span class="line">    fuck = <span class="string">'\033[32m'</span> + s + <span class="string">'\033[0m'</span></span><br><span class="line">    <span class="keyword">print</span> (fuck)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本程序是信息网络与协议课程的一个作业。利用Socket编程和多线程技术实现了两个主机之间的IPv6通信和文件传输。&lt;/p&gt;
&lt;p&gt;代码在ArchLinux系统下测试通过。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="https://www.kingnop.club/tags/Python/"/>
    
      <category term="通信" scheme="https://www.kingnop.club/tags/%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>2016年考研党加油！</title>
    <link href="https://www.kingnop.club/2016/10/05/2016%E5%B9%B4%E8%80%83%E7%A0%94%E5%8A%A0%E6%B2%B9/"/>
    <id>https://www.kingnop.club/2016/10/05/2016年考研加油/</id>
    <published>2016-10-05T12:33:50.000Z</published>
    <updated>2018-10-17T13:48:21.796Z</updated>
    
    <content type="html"><![CDATA[<p>就是试试我还会不会用这个blog<br>2018年6月27日<br><a id="more"></a><br><blockquote class="blockquote-center"><p>世界的本质就是复读机</p></blockquote></p><h1 id="u6240_u6709_u7684_u8003_u7814_u515A_u90FD_u52A0_u6CB9_uFF0C_u90FD_u80FD_u53BB_u81EA_u5DF1_u60F3_u53BB_u7684_u5B66_u6821_uFF01"><a href="#u6240_u6709_u7684_u8003_u7814_u515A_u90FD_u52A0_u6CB9_uFF0C_u90FD_u80FD_u53BB_u81EA_u5DF1_u60F3_u53BB_u7684_u5B66_u6821_uFF01" class="headerlink" title="所有的考研党都加油，都能去自己想去的学校！"></a>所有的考研党都加油，都能去自己想去的学校！</h1><p>加油。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;就是试试我还会不会用这个blog&lt;br&gt;2018年6月27日&lt;br&gt;
    
    </summary>
    
    
      <category term="闲聊" scheme="https://www.kingnop.club/tags/%E9%97%B2%E8%81%8A/"/>
    
  </entry>
  
  <entry>
    <title>改革派</title>
    <link href="https://www.kingnop.club/2015/12/22/HYB/"/>
    <id>https://www.kingnop.club/2015/12/22/HYB/</id>
    <published>2015-12-22T15:36:43.000Z</published>
    <updated>2015-12-22T16:04:12.281Z</updated>
    
    <content type="html"><![CDATA[<p>偶然从知乎日报上读到的一篇文章。<br>正好最近正在看《邓小平时代》，觉得写的不错，转载来收藏。<br><a id="more"></a><br>原文作者：维诺，记者，评论人</p><p>“他们现在，就是要把胡耀邦说成CPC的耀邦，但人们纪念耀邦，是因为他是人民的耀邦。”2015年11月19日，在the Central Committee of CPC召开胡耀邦百年诞辰座谈会的前一天，吴伟对我说。<br>62岁的吴伟曾任the Central Committee of CPC政治体制改革研究室处长和研究员，参与起草80年代政改总体设想，担任原the Central Committee of CPC的政改研讨小组办公室主任BaoTong的秘书。他于1989年因Tiananmen事件而被审查。<br>“官方纪念胡耀邦的出发点，是把胡耀邦作为一种执政党所余不多的正资产，他们希望将这个被冷落的正资产盘活，并且让它增值。纪念胡耀邦的主题，就是把胡耀邦的一生，归结为Party的耀邦，把他在改革开放以后，所做的绝大多数事情，<br>都说成是从Party的利益出发。”吴伟的这一论断在第二天，得到了来自最高层的印证。</p><h1 id="1__u662F_u515A_u7684_u8000_u90A6_uFF0C_u4E0D_u662F_u4F60_u7684_u8000_u90A6"><a href="#1__u662F_u515A_u7684_u8000_u90A6_uFF0C_u4E0D_u662F_u4F60_u7684_u8000_u90A6" class="headerlink" title="1 是党的耀邦，不是你的耀邦"></a>1 是党的耀邦，不是你的耀邦</h1><p>官方越纪念胡耀邦，胡耀邦生前所推行的党内民主改革、防止个人崇拜专断，越发远去。<br>2015年11月20日，作为执政党的CPC举行了胡耀邦百年诞辰纪念座谈会，几乎同时，《胡耀邦文选》出版，《胡耀邦》电视纪录片上映。<br>胡耀邦曾于1980年至1987年担任总书记 of the Central Committee of CPC，由于其在任期间，积极推动政治与经济改革，推行“废除领导职务终身制”，对student movements保持宽容，因此在1987年1月连续七天的“党内生活会”中，<br>被党内保守派“逼宫”下台。1989年，因为胡耀邦的突然逝世，学生大规模自发悼念并提出政治民主等要求，由此引发了震惊中外的“535事件”——也因此，胡耀邦在其身后多年，一直都是CPC的“心结”所在。<br>表面上，本次高规格纪念座谈会，the Central Committee of CPC给这位曾经的名义最高领袖“平反”了。但处理方式值得玩味，对于胡曾经完全不合程序地被党内老人“逼宫”下台，以及遭到的“反资产阶级自由化不力”的指控，<br>执政党则似乎全然不知，更不用说因其去世而引发的student movements了。<br>对比胡耀邦诞辰90周年上，彼时国家副主席曾庆红与今年president的讲话，会发现显著的不同。在2005年的纪念谈话中，曾庆红赞扬胡耀邦“探索党和国家领导体制的改革”，到100年时的更高规格座谈会时，president则只字不提。<br>2005年曾庆红称赞他“为加强和改善党的领导做了大量工作”，這一点在2015年也大量简化，其中胡耀邦“反对个人崇拜”、“完善党内民主”的表述，已不复存在。<br>近年来，党内民主人士与党外改革人士常借胡耀邦来纪念80年代中国的锐意改革，并寄望未完成的民主政治改革可以早日重启。但这显然不是今天执政党纪念胡耀邦的意思。<br>在纪念胡耀邦诞辰100周年时，president的讲话中专门添加了胡耀邦对共产主义和马克思主义的坚守：“那种认为‘communism是渺茫的幻想’、‘communism没有经过实践检验’的观点，是完全错误的。”但对胡耀邦如何理解马克思主义，如何推动民主政治改革，则视而不见。<br>如吴伟所说，president正在将胡耀邦作为CPC的政治资源盘活——“盘活”CPC历史中原本冲突矛盾、难以自圆其说的地方，求取最大公约数，为我所用，从而重建正当性，也成了CPC斯巴达大会以来鲜明的执政特色。<br>于是纪念邓小平110周年诞辰时，president将“坚守communism信仰”描述为邓的首要美德；纪念被认为是保守派的陈云110周年诞辰，president又称陈云积极支持邓小平的改革开放。太祖时代与邓小平时代如何打通？一句“前后两个三十年互不否定”就解决了问题。<br>这一场“高规格“的、早在2015年初，就让党内党外的民主改革人士怀有期待的座谈会，不仅没有带来丝毫希望，反而让人更加错愕。他们目睹了如此吊诡的场景——官方越纪念胡耀邦，胡耀邦生前所推行的党内民主改革、防止个人崇拜专断，就越发远去。<br>而与此同时，胡耀邦本人，与追随他遗志的改革人士一样，也陷入了前所未有的尴尬与失落。</p><h1 id="2__u5C34_u5C2C_u7684_u515A_u5185_u6C11_u4E3B_u4EBA_u58EB_uFF0C_u5FAE_u5F31_u7684_u62B5_u6297"><a href="#2__u5C34_u5C2C_u7684_u515A_u5185_u6C11_u4E3B_u4EBA_u58EB_uFF0C_u5FAE_u5F31_u7684_u62B5_u6297" class="headerlink" title="2 尴尬的党内民主人士，微弱的抵抗"></a>2 尴尬的党内民主人士，微弱的抵抗</h1><p>仅仅3年时间，改革“派”就几乎彻底“退场”。整个2015年，对于political reform还怀有期待的人士，都把纪念胡耀邦看成一个或许象征最后希望的政治风向标。由于拿不准政治尺度，不知道官方会如何纪念，诸多媒体仍然战战兢兢。<br>而临近胡耀邦百年诞辰时，大部分国内媒体接到propaganda department的通知：在专题文章上，市场化媒体不能有自选动作，也就是说，只能转载官方媒体统一报道。 只有少数媒体坚持了安全线以内的“自选动作”。写作纪念文章的人，多是党内主张民主改革的学者。<br>《财经》杂志刊发了中央社会主义学院政治学教授王占阳的文章《胡耀邦的富民思想》。王占阳被视为党内民主派学者的代表人物。一直以来，他提倡“普世的宪政社会主义”，在他的论述中，有“两面大旗”，一面是马克思，一面是邓小平。<br>他把马克思解释为“主张宪政民主政体”，把邓小平解释为“主张社会主义市场经济”。在此前与胡耀邦之子胡德平共同出席的座谈会中，他也曾提出CPC是“长期执政，完成执政使命”，而非“永远执政”。<br>以此种方式要求党内改革的声音，曾在2012年斯巴达换届之际频繁出现。但很显然，新一届领导人完全拒绝了这一呼吁——要求CPC自我改革的强烈声音，在这两年来已近乎绝迹。<br>一直被视为党内民主派老人的发言阵地《炎黄春秋》，此次也刊发了与官方定调截然不同的纪念声音。原Centre Committee of CPC办公厅调研室正局级研究员郝怀明发表文章《胡耀邦与Party的现代化》，文章提到胡耀邦反对在任何事上与中央保持一致的观点，而应该发扬民主。<br>中央党校党史部教授王海光也在《炎黃春秋》杂志发表文章，其中引用1980年胡耀邦参与起草的《关于党内政治生活的若干准则》，并发出质问：“反对个人专断，发扬党内民主，这35年来究竟落实了多少？是不是颇有‘好了伤疤忘了疼’的感慨？”<br>“好了伤疤忘了疼”显然意有所指，中共刚刚在几周前通过了新版的《党纪处分条例》，其中要求党员不得“妄议中央大政方针，破坏党的集中统一”，违反者将被给与警告，撤销职务，甚至开除党籍的处分。<br>财新网发表了中央党校教授蔡霞的文章《胡耀邦——推动全面改革的政治家》，蔡霞将胡耀邦的形象重新置位，其中详细论述胡耀邦致力于“推动解放思想、发扬理论民主、纠正党内左的组织路线、加强民主法治建设、推动政治改革……”这与president只字不提、甚至截然相反的论述相互龃龉，所以甫一发出，即被删除。<br>由与胡耀邦家族关系密切，长期从事胡耀邦研究的李盛平所主持的胡耀邦史料信息网，成为纪念胡耀邦、并且呼吁中国共产党政治改革的最后一块阵地。但显然，胡家人对president的纪念讲话相当不满，因此在胡耀邦史料信息网的首页头条，放置的仍然是ZY真人的讲话（追悼会）、曾庆红的讲话（90周年），而现任president的讲话——或许是作为无声的抗议，则不见踪影。<br>采访中，一位党史学者对我说，“两年来发生的种种大行其道的极左言论，为什么在上一任的时代是没有的？你能说这和当今最高领导人的主张是没有关系的吗？”<br>在2012年，十八大中共换届之时，学者荣剑曾预言，八十年代的改革派，很可能随着president的上台而“返场”与“登场”了。但事实情况却是，仅仅3年时间，改革“派”就几乎彻底“退场”。<br>总之，在“不讲宪政”、“不讲普世价值”、“不讲公民社会”的官方主张占据舆论场，同时也是官方大规模纪念胡耀邦诞辰百年的今天，这零星的四五篇文章，便是体制内改革派最后的微弱集结了。</p><h1 id="3__u66FE_u7ECF_u96C6_u4F53_u4EAE_u76F8_u7684_u515A_u5185_u6C11_u4E3B_u201C_u6D3E_u201D"><a href="#3__u66FE_u7ECF_u96C6_u4F53_u4EAE_u76F8_u7684_u515A_u5185_u6C11_u4E3B_u201C_u6D3E_u201D" class="headerlink" title="3 曾经集体亮相的党内民主“派”"></a>3 曾经集体亮相的党内民主“派”</h1><p>2009年是自1989年以后，党内民主人士最接近“派别”气象的一次集体亮相。对比胡耀邦百年诞辰官方的大规模纪念，党内民主人士的自发纪念与软弱“抵抗”，当然太过吉光片羽，微不足道。<br>然而六年前，在2009年胡耀邦逝世20周年之际，党内民主人士曾有大规模的纪念活动，甚至被民间视为一次“党内民主派”的集体亮相。<br>彼时，在前中宣部长朱厚泽的支持下，自由主义学者张博树等人策划了《胡耀邦与中国政治改革：12位老CPC人的反思》一书在香港出版，以此纪念胡耀邦逝世及Tiananmen运动20周年。<br>众多赫赫有名的党内民主人士——李锐、胡绩伟、谢韬、何方、辛子陵、张显扬、杜光、钟沛璋、林京耀、宋以敏、王家典、周成启等12位老CPC人，都各写一篇要求CPC推动political reform的文章，港媒和外媒均跟进报道，一时引发海内外剧烈反响。<br>不止于此，同年，李锐、朱厚泽、杜导正、曾彦修、张思之等党内民主人士在香港《争鸣》杂志发表给时任国家主席胡锦涛并members of the Standing Committee of the Political Bureau的公开信，要求扩大舆论监督、保障公民社会，<br>进行political reform。这被媒体称为“零九上书”，一些人士甚至认为，“零九上书”与dissidents 刘XB所组织的“08 charter”相映照，成为党内党外合力推动民主的写照。<br>事实上，CPC党内民主人士从未形成真正意义上的“派别”。在采访中，当我称一位中央党校教授为“党内民主派”的时候，他明确拒绝这个称号，因为“从来就没什么派”——而2009年，则是自1989年以后，党内民主人士最接近“派别”气象的一次集体亮相。<br>党内民主“派”在CPC斯巴达大会前一度相当活跃，他们曾被视为推动中国民主转型的重要力量。除了09年的“集体亮相”，这些党内民主人士以个人之声，多在《炎黄春秋》发表自己对时局的见解，以及对political reform的大声疾呼。<br>前社科院副院长谢韬于2007年在《炎黄春秋》杂志直言不讳——发表文章《只有民主社会主义才能救中国》，他认为“政治体制改革再也不能拖延了”，因为“企图保留毛模式的政治体制，只在经济上改革开放，<br>会重蹈蒋介石国民党在大陆走向灭亡的官僚资本主义道路”，“只有民主宪政才能从根本上解决执政党贪污腐败问题。”然而天不假年，他于2010年逝世。<br>曾任毛秘书的耄耋老人李锐，现在仍然担任《炎黄春秋》顾问，他在2009年胡耀邦逝世20周年之际，发表文章《不当奴隶，更不当奴才》——其中已经直白无遗地提出，如果要完成胡耀邦的遗愿，<br>不能再走one-party system的老路，“首先开放言论自由、实行舆论监督……必须当政分开，政企分开，依法治国，实施宪政。”<br>更为悲观的是同样已经逝世的前中宣部长朱厚泽，他与胡耀邦关系深厚，被视为CPC党内民主“派”的灵魂人物。晚年朱厚泽对“中国模式”嗤之以鼻，直言中国的政治despotism、经济发展模式，很可能给本国和世界造成灾难后果。<br>然而这般呼吁民主的“盛况”，不再可能出现在今天。</p><h1 id="4__u88AB_u6536_u7F16_u7684_u8A00_u8BBA_u9635_u5730"><a href="#4__u88AB_u6536_u7F16_u7684_u8A00_u8BBA_u9635_u5730" class="headerlink" title="4 被收编的言论阵地"></a>4 被收编的言论阵地</h1><p>《炎黄春秋》被收编后，预计在香港出版的《转型中国》杂志被叫停。除了09年的集体亮相，如果说党内民主人士有常规的组织化力量，《炎黄春秋》杂志则堪当此任。<br>它是能够集结党内民主人士和党外liberalism倾向学者的重要阵地，也像是一枚信号器——如果它骤然衰败，则必定是不祥信号。而2014年，发生在《炎黄春秋》的动荡，很可能标志着CPC党内民主“派”的断崖式失语。<br>2014年9月，国家新闻出版广电总局发出通知，要求《炎黄春秋》的主管单位由原来的中华炎黄文化研究会更改为文化部下属的中国艺术研究院——这一明显的收编举动，试图强行“管住”《炎黄春秋》，迅速引发了《炎黄春秋》的内部动荡。<br>知情人士告诉我，总编辑吴思和执行主编洪振快都反对这一收编行为。而杂志社内部在此次决议中，社长杜导正——这位党内民主人士——亲自违背了他定下的“议事三原则”，亦即炎黄春秋内部的民主议事规程——最终导致总编辑吴思与执行主编洪振快愤而辞职。<br>相关人士告诉我，《炎黄春秋》近来言论空间急剧收窄，以前相对的大胆言论，已几乎不再可能出现。与此同时，“守纪律”、“讲规矩”是十八大以来CPC对party member的最新要求，而最近颁布的新版《中国共产党纪律处分条例》，<br>则直接发展成为party member“不得妄议中央大政方针”——在此背景下，断崖式失语，自是党内民主“派”的必然结局。鲜为人知的是，从《炎黄春秋》辞职的核心编辑并非束手就擒，他们曾试图在香港打开一块言论空间。<br>多次访谈中，知情人士告诉我，曾经以“皇甫平”为笔名与保守派笔战、在90年代初期撰文为中国改革开放鼓呼的周瑞金，在《炎黄春秋》被收编事件发生后不久，找上了从该杂志辞职的吴思与洪振快，希望在香港办一本杂志，名为《转型中国》。<br>周瑞金是浙江人，在浙江商人中影响广泛，因此得到了一位浙商约一年三百万的资金资助。《转型中国》本来预计在2015年5到6月出版创刊号，第一期就是吴思、王占阳、任剑涛、尹宝云、马立诚、张木生等党内民主“派”的文章与演讲，共同就CPC混乱的意识形态转型，提出解决方案与出路——<br>然而“来自相当高层的压力”，分别找到周瑞金与出资浙商，要求停办《转型中国》，否则“会有很严重的后果”——最终，这本杂志还未出生，便无声无息的死亡。<br>如果说，在2013年官方的“反宪政”浪潮下，党内民主“派”还能够发起声势浩大的反攻；那么2014年，无疑是党内民主“派”近乎彻底销声匿迹的一年，这一衰败趋势，延续了整个2015年。<br>也正因此，2015年在党内民主精神领袖胡耀邦的百年诞辰中，他们再也没办法像2009年那样，吹起集结号了。</p><h1 id="5__u6539_u9769_u201C_u6D3E_u201D_u5F25_u6F2B_u7684_u60B2_u89C2_u5FC3_u7EEA"><a href="#5__u6539_u9769_u201C_u6D3E_u201D_u5F25_u6F2B_u7684_u60B2_u89C2_u5FC3_u7EEA" class="headerlink" title="5 改革“派”弥漫的悲观心绪"></a>5 改革“派”弥漫的悲观心绪</h1><p>如今相逢，彼此的悲观心绪，已难以掩盖。老一辈民主人士对于有生之年，能够看到一个良序的民主中国，大部分都感到极其悲观。<br>党内民主“派”与党外渐进改革“派”，事实上是一枚硬币的两面，他们的主张趋同，而由于身份不同，话语策略有所差异——但其核心就是党内党外合力，无论是来自共识合作，还是来自民间倒逼。<br>在斯巴达大会前后，党外的渐进民主主义者曾对现任最高领导人充满想象。他们追溯president父亲的改革历程，以及其父为胡耀邦的鸣冤不平，遵照这一脉络，期冀子承父愿，president能够推动中国走向民主转型。<br>而三年过去，无论是否愿意承认，对于现任president的美好想象，已经一个接一个的落空。在北京党内外民主人士的交谈中，如今流传着对president另类的话语观察。<br>“除了正式文件外，他所有的即席谈话，都是毛时代的一套言论，”我分别从北京的一位政治学者和一位党史学者处听到相同的结论。尽管president热衷于长串的书单，但愈发粗鄙的红色话语现象，从政治语象研究上也得到清晰印证。<br>香港大学中国传媒研究计划主任钱钢长期研究中共政治语象，他认为，作为列宁主义政党，CPC重视宣传、迷恋口号、习惯动员，政治表述是政治发展的风向标，通过观察这些“关键”词汇的诞生、消长与衰亡，可以从中读出CPC政治的发展方向。<br>CPC政治词汇可以用深蓝、浅蓝、浅红、深红来分类，深蓝是被CPC批判的强烈liberal词汇（如：multi-party system），浅蓝是官方不倡不禁的温和自由化词汇（如：公民社会、公民权利），浅红是官方的门面修饰用语（如：三个代表、科学发展观），<br>而深红则是露骨的毛时代用词（如：刀把子、阶级斗争、无产阶级专政）。而与政治改革直接相关的词汇，钱钢以三组浅红词语（党内民主、民主政治、政治文明），三组浅蓝词语（宪政、公民社会、公民权利）做观察：<br>从2014年以来，这三组原本为官方所用的浅红色词语被打入浅蓝，官方基本不再提及。原本可以出现在市场化媒体的浅蓝色词汇，则直接被打入深蓝禁区，媒体基本不得再使用。而深红词语，如“刀把子”、“阶级斗争”等毛时代的粗鄙词汇，则一个接一个的复活。<br>政治变化也剧烈搅动人心。与诸多老一辈民主人士交谈，我感喟最多的，是三年未至，变化倏然。两年多前，他们普遍会倡导某种程度的渐进主义，亦或是“日拱一卒，不期速成”的良好愿望。许多耳顺之年的人士，<br>会对自己在有生之年，看到一个拥有自由秩序的民主中国怀有信心——谨慎乐观，是彼时的普遍心理。而如今相逢，我们一旦谈论国事，彼此的悲观心绪，已难以掩盖。他们对于有生之年，能够看到一个良序的民主中国，大部分都感到极其悲观。<br>一位中央党校教授对我表达了自己对中国未来的深度悲观：现在的高压状态无法永续，但由于中间阶层的社会力量被完全打压，良好民主不可能到来，“在未来，一场动荡失序不可避免。”<br>他重点谈到的是对如今中国官僚集团“怠政”的观察，“party不把干部当人，而把干部当狗”，“升迁的时候不顾你的胡作非为、黑色收入，打击你的时候也没有任何人权可言”，<br>“旧的激励机制没了，新的激励机制根本没有”——由于执政党不再能够完全控制和激励官僚体系，他认为，“中国经济发展的困境，与如今官员不敢作为有相当大的关系。”<br>这一切让诸多人士怀疑，渐进主义一开始就不应该出现，因为那是“贩卖虚假希望”。然而，党内“中左”与党外“中右”合力推动转型的迹象，并非从未存在过——它曾引起过党内外呼吁民主的空前共鸣。</p><h1 id="6__u6E10_u8FDB_u4E3B_u4E49_u7834_u4EA7_u4E86_u5417_uFF1F"><a href="#6__u6E10_u8FDB_u4E3B_u4E49_u7834_u4EA7_u4E86_u5417_uFF1F" class="headerlink" title="6 渐进主义破产了吗？"></a>6 渐进主义破产了吗？</h1><p>渐进民主主义所依赖的合力与倒逼，条件看起来已经完全丧失：党内民主“派”偃旗息鼓，党外力量完全被打压，整个社会彻底散沙化，原子化的个人将直接面对国家机器。<br>党内外合力推动改革的希望，最为振奋人心的是在2010年。是年8月20日到9月30日，时任国务院总理温家宝在不同场合，七次直接呼吁political system reform，一时间引起海内外巨大关注。<br>香港大学中国传媒研究计划主任钱钢迅速整理出版了《政治改革大博弈——温家宝七谈political reform》一书，在该书中，他写道：<br>“（温家宝七谈political reform）无疑是中国政治发展史的重要事件，有朝一日，political reform大戏揭幕，扣人心弦的演变一幕幕展开，人们将会越来越清楚的看到‘温家宝七谈political reform’之不寻常的意涵。”<br>许多后来对渐进民主嗤之以鼻的党内外民主人士，在彼时都曾异口同声地声援“孤独”的温家宝。事实上，那时候除了余杰等少数一以贯之的激进反对人士以外，甚至因Tiananmen事件流亡海外的学者Hu Ping也因国务院总理的呼吁，而看到了某种渐进民主的希望。他甚至以535为例——<br>“现在一般人都承认，胡、赵算得上民主派。但是我们不要忘记了，胡赵的民主派身份都是在他们下台之后才认出来的……（我们）对以赵紫阳、张爱萍、Bao Tong、闫明复、胡绩伟等为代表的CPC内愿意严守现代文明准则的力量，严重缺乏了解和缺乏信任。”<br>“一个在位者，即便他是真正的改革派，也不可能毫无保留地讲出自己的理念，那么我们不妨反过来想，如果有这样的改革派，他能对外讲到什么程度。”然而，无论温家宝只是“影帝”，还是在党内孤掌难鸣，总之他“风雨无阻，至死方休”的推动政改，最终在其卸任之际，也没有任何实质进展。<br>但无论如何，彼时一谈“改革”，其面相是“向前”的，而非近三年飞速回望毛时代的“全面深化改革”。它亦曾让整个社会为之一振，让党内外前所未有的共鸣激荡——而到如今，党内外合力的渐进民主，再难寻找些微端倪。<br>在中国推动渐进民主，由党内“中左”（体制内社会民主主义人士）与党外“中右”（民间自由主义温和派）合力推动中国转型——这曾是four gentlemen of Tiananmen之一的Zhou Duo，所最先在中国倡导的良性民主转型方式（参见自由主义学者张博树《中国宪政改革可行性研究报告》），<br>并且拥有关于渐进民主的一套完整论述。在他看来，按照这样的路径走向英美宪政模式，转型之路不至于彻底失序，造成剧烈动荡。<br>一直以来，他主张达成精英共识，然后在精英竞争层面，将人大、政协转变为真正的议会，CPC从高居议会之上的“议会老子党”变为在宪法约束之下的议会党，走内源式的multi-party system发育之路。在大众竞争层面，<br>他主张认真推行县市一级的民主选举与司法独立，扩大言论和出版自由。执政党内部则实行多元权力的监督制衡，将一切能让民间社会办到的事情，都让渡给民间社团……<br>Zhou Duo的建言曾在十八大前被其红二代儿时好友送到政研室of the Central Committee，据香港《明报》报道，引起过高层关注。但三年过去，新任执政者几乎在每一条建言上，都做出了相反举措。<br>单独是2013年General Office of the CPC Cenral Committee印发的《关于当前ideology领域情况的通报》，即“Seven不讲”的“9号文件”就告知了真相——不讲宪政、不讲普世价值、不讲公民社会、不讲新自由主义、不讲西方新闻观、历史虚无主义以及质疑改革开放。<br>这份文件将渐进民主的主张全盘推翻，而这之后两年，则是变本加厉的南辕北辙。Zhou Duo也对我坦言，其对president观察失误，“曾经我以为他是’中左’，可以和LKQ这个‘中右’配合得很好，现在看来是高看他了。”<br>这让渐进主义理论更显尴尬，这一套主张被官方极权主义与民间激进主义共同绞杀，一旦渐进的主张被官方毫不留情地打压之时，民间激进人士便会更加剧烈的嘲笑讽刺。他们被讥刺为“货与帝王家”、“替国务院操心”、“递折子”……如果超越任何道德评价，<br>激进人士的嘲讽揭露了一个事实——渐进民主主义的主张已经完全不能解释如今的状况，其所依赖的合力与倒逼，条件看起来已经完全丧失：党内民主“派”偃旗息鼓，党外力量完全被打压，整个社会彻底散沙化，原子化的个人将直接面对国家机器。<br>对其更为深刻的批评来自于政治学者王天成，这位“快速变革”主张者在其代表作品《大转型：中国民主化战略研究框架》一书中对“渐进主义”的理论缺陷直言不讳，称渐进主张“对民主转型的性质和过程缺乏基本认识”，<br>是一种“想当然的设想”。因为渐进主义者无法回答——在如今的准极权控制时代，CPC如何会自愿的从凌驾于一切之上的“老子党”变成议会党？而人大政协如何能够转化为议会？后极权政体如何会转化为分权制衡的宪政体制？……<br>针对这些问题，Zhou Duo都没有直接回答我。他仍然还坚持着想方设法“递折子”。必须承认，他的一点观察仍是对的——“在这个权力体制下，最高层不改，其他说什么都没用。”<br>事实可能的确如此。在一个准极权体制下，既不存在渐进民主改革的可能，也同样不存在revolution的可能。“朝中没有袁世凯，在野没有孙中山”，是民主人士不得不面对的尴尬事实，而这也注定了中国社会未来的冰河时期。<br>“中国的president正在带领中国第二次探底。毛泽东是第一次，这是第二次。”在访谈最后，一位中国社科院历史学者对我说。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;偶然从知乎日报上读到的一篇文章。&lt;br&gt;正好最近正在看《邓小平时代》，觉得写的不错，转载来收藏。&lt;br&gt;
    
    </summary>
    
    
      <category term="政治" scheme="https://www.kingnop.club/tags/%E6%94%BF%E6%B2%BB/"/>
    
  </entry>
  
  <entry>
    <title>C#学习笔记（二）</title>
    <link href="https://www.kingnop.club/2015/11/15/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://www.kingnop.club/2015/11/15/C-学习笔记（二）/</id>
    <published>2015-11-15T15:39:56.000Z</published>
    <updated>2018-10-17T10:51:56.520Z</updated>
    
    <content type="html"><![CDATA[<p>还是面向对象的部分，下一部分就开始windows窗体编程了。<br><a id="more"></a></p><h1 id="u8FD0_u7B97_u7B26_u91CD_u8F7D"><a href="#u8FD0_u7B97_u7B26_u91CD_u8F7D" class="headerlink" title="运算符重载"></a>运算符重载</h1><p>用+-*/直接进行复数运算<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Complex</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//实部和虚部</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span> a,b;</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Complex</span><span class="params">(<span class="keyword">double</span> real, <span class="keyword">double</span> imgai)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        a = real;</span><br><span class="line">        b = imagi;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重载+运算符</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Complex <span class="keyword">operator</span> +(Complex z1, Complex z2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Complex(z1.a + z2.a, z1.b + z2.b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重载-运算符</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Complex <span class="keyword">operator</span> -(Complex z1, Complex z2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Complex(z1.a - z2.a, z1.b - z2.b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重载*运算符</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Complex <span class="keyword">operator</span> *(Complex z1, Complex z2)</span><br><span class="line">    &#123;</span><br><span class="line">        Complex z = <span class="keyword">new</span> Complex(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        z.a = (z1.a * z2.a - z1.b * z2.b);</span><br><span class="line">        z.b = (z1.b * z2.a + z1.a * z2.b);</span><br><span class="line">        <span class="keyword">return</span> z;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重载/运算符</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Complex <span class="keyword">operator</span> /(Complex z1, Complex z2)</span><br><span class="line">    &#123;</span><br><span class="line">        Complex z = <span class="keyword">new</span> Complex(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">double</span> denominator = (z2.a * z2.a + z2.b * z2.b);</span><br><span class="line">        z.a = (z1.a * z2.a + z1.b * z2.b)/denominator;</span><br><span class="line">        z.b = (z1.b * z2.a - z1.a * z2.b)/denominator;</span><br><span class="line">        <span class="keyword">return</span> z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样就实现了对运算符的重载，当进行计算时，编译器先对运算符两端的数据类型进行比较，若为Complex对象则调用重载的函数进行计算，否则调用默认的计算方式。<br><strong>不必重载复合运算符（+=），只要重载了相应的普通运算符（+）即可以</strong></p><h1 id="u7D22_u5F15"><a href="#u7D22_u5F15" class="headerlink" title="索引"></a>索引</h1><p>索引可以让我们像数组那样访问类的数据成员<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cube</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> length, width, height;</span><br><span class="line">    <span class="comment">//省略构造函数</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//索引</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span> <span class="keyword">this</span>[<span class="keyword">int</span> index]</span><br><span class="line">    &#123;</span><br><span class="line">        get</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">switch</span> (index)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>: <span class="keyword">return</span> length;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>: <span class="keyword">return</span> width;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>: <span class="keyword">return</span> hright;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfRangeException(<span class="string">"下标出界！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        set</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">switch</span>(index)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>: length = value;<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>: width = value;<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>: height = value;<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfRangeException(<span class="string">"下标出界！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>与属性相似，也用set和get两个访问器。索引的使用方法和数组完全一样。如果我们创建了一个名为box的Cube对象，就可以用box[0],box[1],box[2]分别表示length,width和height。<br><strong>索引的下标可以不是数，可以为double, string等类型</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">double</span> <span class="keyword">this</span>[string indexString]</span><br><span class="line">    &#123;</span><br><span class="line">        get</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">switch</span> (indexString)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"length"</span>: <span class="keyword">return</span> length;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"width"</span>: <span class="keyword">return</span> width;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"height"</span>: <span class="keyword">return</span> hright;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfRangeException(<span class="string">"下标出界！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        set</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">switch</span>(index)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"length"</span>: length = value;<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"width"</span>: width = value;<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"height"</span>: height = value;<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfRangeException(<span class="string">"下标出界！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h1 id="u58F0_u660E_u6570_u7EC4_u5BF9_u8C61"><a href="#u58F0_u660E_u6570_u7EC4_u5BF9_u8C61" class="headerlink" title="声明数组对象"></a>声明数组对象</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cat[] cats = <span class="keyword">new</span> Cat[<span class="number">5</span>];</span><br></pre></td></tr></table></figure><p>和声明普通数组的方式相同。<br>但以上语句只是声明了一组“引用符”而已，并没有创建对象，下面的语句让每个引用符指向一个对象<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0;i &#60; cats.Length; i++)&#10;&#123;&#10;    cats[i] = new Cat();&#10;&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;还是面向对象的部分，下一部分就开始windows窗体编程了。&lt;br&gt;
    
    </summary>
    
      <category term="C#" scheme="https://www.kingnop.club/categories/C/"/>
    
    
      <category term="C#" scheme="https://www.kingnop.club/tags/C/"/>
    
      <category term="学习笔记" scheme="https://www.kingnop.club/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>c#学习笔记（一）</title>
    <link href="https://www.kingnop.club/2015/10/28/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://www.kingnop.club/2015/10/28/C-学习笔记（一）/</id>
    <published>2015-10-27T17:02:16.000Z</published>
    <updated>2018-10-12T09:06:38.455Z</updated>
    
    <content type="html"><![CDATA[<p>今天开始学习C# 尽量坚持下去！  keep fighting!<br>这一部分是面向对象的部分<br><a id="more"></a></p><h1 id="u5C5E_u6027_uFF08Property_uFF09"><a href="#u5C5E_u6027_uFF08Property_uFF09" class="headerlink" title="属性（Property）"></a>属性（Property）</h1><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> Age</span><br><span class="line">&#123;</span><br><span class="line">    get</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    set</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(value &lt;= <span class="number">0</span>)</span><br><span class="line">            age = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            age = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>get 和 set 是两个访问器，get用来读取变量的值，set用来设置变量的值。其中set访问器中有一个隐式声明的变量value。<br>使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Kitty.Age = <span class="number">3</span>; <span class="comment">//用属性Age为变量age赋值（使用set）</span></span><br><span class="line">Console.WriteLine(Kitty.Age); <span class="comment">//用属性Age读取变量age的值（使用get）</span></span><br></pre></td></tr></table></figure><h1 id="u6784_u9020_u51FD_u6570"><a href="#u6784_u9020_u51FD_u6570" class="headerlink" title="构造函数"></a>构造函数</h1><p>每个类都有一个默认的与类同名的构造函数用来初始化对象的成员变量。当创建对象的时候，系统会调用默认的构造函数，用默认值初始化所有成员变量的值。（int-&gt;0  float-&gt;0.0  bool-&gt;false  string-&gt;null）</p><p>构造函数必须和类同名，并且没有返回类型。<br>我们还可以定义带参数的构造函数<br>例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">(string nameValue, <span class="keyword">int</span> ageValue)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="comment">//初始化变量</span></span><br><span class="line">        name = nameValue;</span><br><span class="line">        age = ageValue;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>调用以上的构造函数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cat kitty = <span class="keyword">new</span> Cat(<span class="string">"kitty"</span>, <span class="number">3</span>);<span class="comment">//将对象kitty的name和age分别初始化为kitty和3</span></span><br></pre></td></tr></table></figure></p><p><strong>当自定义了构造函数后，默认的无参数构造函数就失效了，如果需要的话必须显示定义。</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">//无参数的构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">()</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        name = kitty;</span><br><span class="line">        age = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//有参数的构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">(string nameValue, <span class="keyword">int</span> ageValue)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="comment">//初始化变量</span></span><br><span class="line">        name = nameValue;</span><br><span class="line">        age = ageValue;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="u6790_u6784_u51FD_u6570"><a href="#u6790_u6784_u51FD_u6570" class="headerlink" title="析构函数"></a>析构函数</h1><p>析构函数也与类同名，只是要在函数名前加~。该函数不带任何参数，也没有返回值。用来<strong>销毁对象</strong>，释放对象所占用的内存空间。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">(string nameValue, <span class="keyword">int</span> ageValue)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="comment">//初始化变量</span></span><br><span class="line">        name = nameValue;</span><br><span class="line">        age = ageValue;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//析构函数</span></span><br><span class="line">    ~Cat()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//code可以做一些在销毁对象时需要做的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>除非必要，一般不需要编写析构函数，也不用向析构函数里添加代码。</p><h1 id="u9759_u6001_u6210_u5458"><a href="#u9759_u6001_u6210_u5458" class="headerlink" title="静态成员"></a>静态成员</h1><h2 id="u9759_u6001_u53D8_u91CF"><a href="#u9759_u6001_u53D8_u91CF" class="headerlink" title="静态变量"></a>静态变量</h2><p>用来描述整个类，所有的实例化对象都可以使用，且<strong>共用内存数据</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> aaa = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></p><p>实例变量通过对象名引用，静态变量通过类名引用。<br>例：Math类的大部分成员均为静态变量</p><h2 id="u9759_u6001_u51FD_u6570"><a href="#u9759_u6001_u51FD_u6570" class="headerlink" title="静态函数"></a>静态函数</h2><p>某些情况下需要类名直接调用函数。下面编写一个Calculate类，它的静态函数可以用来计算两个实数的和，差，积。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Calculate</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">Add</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">Sub</span><span class="params">(<span class="keyword">double</span> x, doulbe y)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x - y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">Multi</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span><span class="params">(string[] args)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> a = <span class="number">123456</span>;</span><br><span class="line">    <span class="keyword">double</span> b = <span class="number">456789</span>;</span><br><span class="line">    <span class="comment">//调用静态函数，通关类名直接调用</span></span><br><span class="line">    <span class="keyword">double</span> sun = Calculate.Add(a,b);</span><br><span class="line">    <span class="keyword">double</span> dif = Calculate.Sub(a,b);</span><br><span class="line">    <span class="keyword">double</span> pro = Calculate.Multi(a,b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="u5E38_u91CF_u6210_u5458"><a href="#u5E38_u91CF_u6210_u5458" class="headerlink" title="常量成员"></a>常量成员</h1><h2 id="const_u5E38_u91CF"><a href="#const_u5E38_u91CF" class="headerlink" title="const常量"></a>const常量</h2><p>在类中建立const常量的方法和函数中基本一样<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="number">3.1415926</span>;</span><br></pre></td></tr></table></figure></p><p>const只能在声明的时候初始化，不能在其他地方赋值，在运行过程中它的值保持不变。<br><strong>类的const常量是隐式静态的，为该类的所有实例化对象共有。所以在类外要通过类名来引用变量。</strong></p><h2 id="readonly_u5E38_u91CF"><a href="#readonly_u5E38_u91CF" class="headerlink" title="readonly常量"></a>readonly常量</h2><p>在类的具体对象中是固定的常数，但在不同的对象中数值可能不同。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> readonly <span class="keyword">int</span> roomNumber;</span><br></pre></td></tr></table></figure></p><h1 id="u91CD_u8F7D_uFF08Overload_uFF09"><a href="#u91CD_u8F7D_uFF08Overload_uFF09" class="headerlink" title="重载（Overload）"></a>重载（Overload）</h1><p>可以在一个类中定义多个名称相同但参数不同的函数，这称为函数的重载。函数重载的调用原则是参数“最佳匹配”，即系统调用参数类型最匹配的那个函数。<br>例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Calcuate</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Divide</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x / y;       </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">double</span> <span class="title">Divide</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x / y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span><span class="params">(string[] args)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">double</span> c = <span class="number">7.0</span>;</span><br><span class="line">    <span class="keyword">double</span> d = <span class="number">3.0</span>;</span><br><span class="line">    <span class="comment">//调用不同的函数来执行。</span></span><br><span class="line">    <span class="keyword">int</span> ans1 = Calculate.Divide(a ,b);</span><br><span class="line">    <span class="keyword">double</span> ans2 = Calculate.Divide(c ,d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天开始学习C# 尽量坚持下去！  keep fighting!&lt;br&gt;这一部分是面向对象的部分&lt;br&gt;
    
    </summary>
    
    
      <category term="C#" scheme="https://www.kingnop.club/tags/C/"/>
    
      <category term="学习笔记" scheme="https://www.kingnop.club/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>ip网关登陆python版</title>
    <link href="https://www.kingnop.club/2015/10/24/ip%E7%BD%91%E5%85%B3%E7%99%BB%E9%99%86python%E7%89%88/"/>
    <id>https://www.kingnop.club/2015/10/24/ip网关登陆python版/</id>
    <published>2015-10-23T17:42:03.000Z</published>
    <updated>2015-10-23T18:12:17.137Z</updated>
    
    <content type="html"><![CDATA[<p>一个简单的python小程序<br>用来登陆东北大学ip控制网关<br><a id="more"></a> </p><h2 id="1-_u6293_u53D6_u6570_u636E_u5305"><a href="#1-_u6293_u53D6_u6570_u636E_u5305" class="headerlink" title="1.抓取数据包"></a>1.<strong>抓取数据包</strong></h2><p>用<strong>wireshark</strong>抓取网页版网关登陆过程中的数据包，配合IE开发者工具，可以看到提交给服务器端的数据包内容由以下几部分构成。</p><pre><code>postData = {    &apos;uid&apos;:&apos;&apos;,                &apos;password&apos;:&apos;&apos;,                &apos;range&apos;: &apos;&apos;,                &apos;operation&apos;: &apos;&apos;,                &apos;timeout&apos;: &apos;&apos;,        }</code></pre><p>其中uid为用户名，password为密码，range为登陆范围（在2015年6月30日之后学校取消了国内和国际的区别，故此项无意义。但仍需提交给服务器。），operation为操作选项(有2个值，connect表示连接，disconnectall表示断开连接)</p><h2 id="2-_u4F7F_u7528python_u7684urllib2_u5305_u63D0_u4EA4post_u4FE1_u606F"><a href="#2-_u4F7F_u7528python_u7684urllib2_u5305_u63D0_u4EA4post_u4FE1_u606F" class="headerlink" title="2.使用python的urllib2包提交post信息"></a>2.<strong>使用python的urllib2包提交post信息</strong></h2><p>python提供的urllib2模块中，只需要以下几行代码即可方便的对指定url提交post信息。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">request = urllib2.Request(posturl,postData,headers)</span><br><span class="line">conn = urllib2.urlopen(request)</span><br></pre></td></tr></table></figure></p><p>其中posturl是要提交的url地址，postdata为提交的数据（一般为字典结构。），headers为数据包的包头信息（一般在做爬虫时若不提交该信息则服务器会拒绝这类请求。）</p><h2 id="3-_u5BF9_u5F97_u5230_u7684_u6D88_u606F_u8FDB_u884C_u5904_u7406"><a href="#3-_u5BF9_u5F97_u5230_u7684_u6D88_u606F_u8FDB_u884C_u5904_u7406" class="headerlink" title="3.对得到的消息进行处理"></a>3.<strong>对得到的消息进行处理</strong></h2><p>在提交post消息后，服务器会返回一个消息（页面），而用read这个方法<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">html = conn.read()</span><br></pre></td></tr></table></figure></p><p>即可得到该页面。随后即可用re或者python出色的beautifulsoup库来对该页面进行处理。由于返回的页面包含中文字符而我们采用的编码格式为utf-8，所以要对该html页面进行编码（python中编码真的是一个非常令人讨厌的东西，所以用python时还是尽量避开中文！）。然后把编码后的东西直接丢给beautifulsoup就好啦。就是这么简单。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">html = unicode(html,<span class="string">'gb2312'</span>).encode(<span class="string">'utf8'</span>)</span><br><span class="line">soup = BeautifulSoup.BeautifulSoup(html)</span><br></pre></td></tr></table></figure></p><p>这个beautifulsoup库相当于一个html解析器。你可以从中提取出任意标签中的消息。比如我发现我需要的提示消息都在td这个标签中，只需要这样写则可以得到所需标签中的信息。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">soup.td.text</span><br></pre></td></tr></table></figure></p><p>关于BeautifulSoup的详细信息请点击<a href="http://www.crummy.com/software/BeautifulSoup/bs4/doc.zh/" target="_blank" rel="external">BeautifulSoup</a></p><h2 id="4-_u53EF_u89C6_u5316_u7684_u8868_u793A"><a href="#4-_u53EF_u89C6_u5316_u7684_u8868_u793A" class="headerlink" title="4.可视化的表示"></a>4.<strong>可视化的表示</strong></h2><p>在可视化方面我选择了使用非常广泛的tkinter库。主要是简单。<br>关于Tkinter的教程请点击<a href="http://www.yiibai.com/python/python_gui_programming.html" target="_blank" rel="external">Tkinter</a></p><h2 id="5-_u4EE3_u7801"><a href="#5-_u4EE3_u7801" class="headerlink" title="5.代码"></a>5.<strong>代码</strong></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#-*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment">#-------------------------------------------------</span></span><br><span class="line"><span class="comment"># 功能:实现东北大学ip网关的登陆，免去了打开浏览器登陆的麻烦</span></span><br><span class="line"><span class="comment"># 作者：kingop</span></span><br><span class="line"><span class="comment"># 完成时间：2015年6月22日</span></span><br><span class="line"><span class="comment"># 版本：0.0.3</span></span><br><span class="line"><span class="comment"># 注意：采用了base64加密。如果有人得到你的存储文件还是能把账号密码还原出来</span></span><br><span class="line"><span class="comment"># 2015年6月30日 校园网取消了国内国际的限制。故将var1和相应的range取消</span></span><br><span class="line"><span class="comment">#-------------------------------------------------</span></span><br><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"><span class="keyword">import</span> urllib2</span><br><span class="line"><span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> Tkinter</span><br><span class="line"><span class="keyword">import</span> tkMessageBox</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="comment">#-------------------------------------------------</span></span><br><span class="line">postData = &#123;    <span class="string">'uid'</span>:<span class="string">''</span>,</span><br><span class="line">                <span class="string">'password'</span>:<span class="string">''</span>,</span><br><span class="line">                <span class="string">'range'</span>: <span class="string">'2'</span>,</span><br><span class="line">                <span class="string">'operation'</span>: <span class="string">''</span>,</span><br><span class="line">                <span class="string">'timeout'</span>: <span class="string">'1'</span>,</span><br><span class="line">            &#125;</span><br><span class="line">posturl = <span class="string">'http://ipgw.neu.edu.cn/ipgw/ipgw.ipgw'</span></span><br><span class="line"><span class="comment">#-------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">if</span> os.path.exists(<span class="string">'nevertouch1.balabala'</span>) <span class="keyword">and</span> os.path.exists(<span class="string">'nevertouch2.balabala'</span>):</span><br><span class="line">    uid = open(<span class="string">'nevertouch1.balabala'</span>,<span class="string">'rb'</span>)</span><br><span class="line">    pwd = open(<span class="string">'nevertouch2.balabala'</span>,<span class="string">'rb'</span>)</span><br><span class="line">    postData[<span class="string">'uid'</span>] = base64.decodestring(uid.readline())</span><br><span class="line">    postData[<span class="string">'password'</span>] = base64.decodestring(pwd.readline())</span><br><span class="line">    uid.close()</span><br><span class="line">    pwd.close()</span><br><span class="line"><span class="comment">#这段文件读取的程序特别蛋疼。。当把用户名和密码存储在同一个文件时会出现在第二次运行时密码默认为换行符的bug  </span></span><br><span class="line"><span class="comment">#而且好像比较麻烦。。所以采用了两个文件的方式。分别存储用户名和密码   只存储一行  即没有那个问题。但是安全性就是问题了</span></span><br><span class="line"><span class="comment">#-------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reg</span><span class="params">(postData,posturl)</span>:</span></span><br><span class="line">    headers = &#123;</span><br><span class="line">               <span class="string">'User-Agent'</span>:<span class="string">'Mozilla/5.0 (Windows N9T 6.3; WOW64; Trident/7.0; rv:11.0) like Gecko'</span>,</span><br><span class="line">               <span class="string">'Referer'</span>:<span class="string">'http://ipgw.neu.edu.cn/basic.html'</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    postData[<span class="string">'uid'</span>] = username.get()</span><br><span class="line">    postData[<span class="string">'password'</span>] = pwd.get()</span><br><span class="line"><span class="comment">#    if var1.get()==1:</span></span><br><span class="line"><span class="comment">#            postData['range'] = '1'</span></span><br><span class="line"><span class="comment">#    elif var1.get()==2:</span></span><br><span class="line"><span class="comment">#            postData['range'] = '2'</span></span><br><span class="line">    <span class="keyword">if</span> var2.get()==<span class="number">1</span>:</span><br><span class="line">            postData[<span class="string">'operation'</span>] = <span class="string">'connect'</span></span><br><span class="line">    <span class="keyword">elif</span> var2.get()==<span class="number">2</span>:</span><br><span class="line">            postData[<span class="string">'operation'</span>] = <span class="string">'disconnectall'</span></span><br><span class="line">    postData = urllib.urlencode(postData)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        request = urllib2.Request(posturl,postData,headers)</span><br><span class="line">        conn = urllib2.urlopen(request)</span><br><span class="line">        html = conn.read()</span><br><span class="line">        conn.close()</span><br><span class="line">        html = unicode(html,<span class="string">'gb2312'</span>).encode(<span class="string">'utf8'</span>)</span><br><span class="line">        soup = BeautifulSoup.BeautifulSoup(html)</span><br><span class="line">        tkMessageBox.showinfo(<span class="string">"Tips"</span>, soup.td.text)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        tkMessageBox.showerror(<span class="string">'Error'</span>, <span class="string">'Please Check Your Connection To The Internet!'</span>)</span><br><span class="line">    fp1 = open(<span class="string">'nevertouch1.balabala'</span>,<span class="string">'wb'</span>)</span><br><span class="line">    fp2 = open(<span class="string">'nevertouch2.balabala'</span>,<span class="string">'wb'</span>)</span><br><span class="line">    a = base64.encodestring(username.get())</span><br><span class="line">    b = base64.encodestring(pwd.get())</span><br><span class="line">    fp1.write(a)</span><br><span class="line">    fp2.write(b)</span><br><span class="line">    <span class="comment">#a = username.get()+'\n'+pwd.get()</span></span><br><span class="line">    fp1.close()</span><br><span class="line">    fp2.close()</span><br><span class="line"><span class="comment">#------------------------------------------------------------------------------------------------</span></span><br><span class="line">root = Tkinter.Tk()</span><br><span class="line">root.title(unicode(<span class="string">'connect'</span>))</span><br><span class="line"><span class="comment">#root.geometry(100*100)</span></span><br><span class="line"><span class="comment">#var1 = Tkinter.IntVar()</span></span><br><span class="line">var2 = Tkinter.IntVar()</span><br><span class="line">pwd = Tkinter.Entry()</span><br><span class="line">pwd.grid(row = <span class="number">1</span>,column = <span class="number">2</span>)</span><br><span class="line">pwd.insert(<span class="number">0</span>, postData[<span class="string">'password'</span>])</span><br><span class="line">pwd[<span class="string">'show'</span>] = <span class="string">'*'</span></span><br><span class="line">pwd_show = Tkinter.Label(root,text = <span class="string">'password: '</span>)</span><br><span class="line">pwd_show.grid(row = <span class="number">1</span>,column = <span class="number">0</span>)</span><br><span class="line">username = Tkinter.Entry(root)</span><br><span class="line">username.grid(row = <span class="number">0</span>,column =<span class="number">2</span>)</span><br><span class="line">username.insert(<span class="number">0</span>, postData[<span class="string">'uid'</span>])</span><br><span class="line">username_show = Tkinter.Label(root,text = <span class="string">'username: '</span>)</span><br><span class="line">username_show.grid(row = <span class="number">0</span>,column = <span class="number">0</span>)</span><br><span class="line"><span class="comment">#range1 = Tkinter.Radiobutton(root,variable = var1,text = 'in',value = 2)</span></span><br><span class="line"><span class="comment">#range1.grid(row = 2,column = 1)</span></span><br><span class="line"><span class="comment">#range2 = Tkinter.Radiobutton(root,variable = var1,text = 'out',value = 1)</span></span><br><span class="line"><span class="comment">#range2.grid(row = 2,column = 2)</span></span><br><span class="line">op1 = Tkinter.Radiobutton(root,variable = var2,text = <span class="string">'connect'</span>,value = <span class="number">1</span>)</span><br><span class="line">op1.grid(row = <span class="number">3</span>,column = <span class="number">1</span>)</span><br><span class="line">op2 = Tkinter.Radiobutton(root,variable = var2,text = <span class="string">'disconnect'</span>,value = <span class="number">2</span>)</span><br><span class="line">op2.grid(row = <span class="number">3</span>,column = <span class="number">2</span>)</span><br><span class="line">submit = Tkinter.Button(root,text = <span class="string">'log in'</span>,command = <span class="keyword">lambda</span>:reg(postData,posturl))</span><br><span class="line">submit.grid(row = <span class="number">4</span>,column = <span class="number">1</span>)</span><br><span class="line">cancle = Tkinter.Button(root,text = <span class="string">'quit'</span>,command = root.quit)</span><br><span class="line">cancle.grid(row = <span class="number">4</span>,column = <span class="number">2</span>)</span><br><span class="line">root.mainloop()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个简单的python小程序&lt;br&gt;用来登陆东北大学ip控制网关&lt;br&gt;
    
    </summary>
    
    
      <category term="python" scheme="https://www.kingnop.club/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>好多bug...</title>
    <link href="https://www.kingnop.club/2015/10/20/%E5%A5%BD%E5%A4%9Abug/"/>
    <id>https://www.kingnop.club/2015/10/20/好多bug/</id>
    <published>2015-10-20T05:20:00.000Z</published>
    <updated>2015-10-20T05:20:00.894Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>我的第一个blog</title>
    <link href="https://www.kingnop.club/2015/10/20/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAblog/"/>
    <id>https://www.kingnop.club/2015/10/20/我的第一个blog/</id>
    <published>2015-10-19T16:15:47.000Z</published>
    <updated>2015-10-23T17:40:40.067Z</updated>
    
    <content type="html"><![CDATA[<p>blog终于正式运作起来了。睡觉去咯。<br>Good night!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;blog终于正式运作起来了。睡觉去咯。&lt;br&gt;Good night!&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
</feed>
